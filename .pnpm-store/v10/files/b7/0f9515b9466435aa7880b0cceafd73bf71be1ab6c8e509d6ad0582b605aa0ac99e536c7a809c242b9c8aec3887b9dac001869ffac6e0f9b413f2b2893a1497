var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/registerMethods.ts
var registerMethods_exports = {};
__export(registerMethods_exports, {
  default: () => registerMethods_default
});
module.exports = __toCommonJS(registerMethods_exports);
var import_es_module_lexer = require("@umijs/bundler-utils/compiled/es-module-lexer");
var import_utils = require("@umijs/utils");
var import_assert = __toESM(require("assert"));
var import_fs = require("fs");
var import_path = require("path");
var import_isTypeScriptFile = require("./utils/isTypeScriptFile");
var registerMethods_default = (api) => {
  [
    "onGenerateFiles",
    "onBeforeCompiler",
    "onBuildComplete",
    "onBuildHtmlComplete",
    "onPatchRoute",
    "onPkgJSONChanged",
    "onPrepareBuildSuccess",
    "onDevCompileDone",
    "onCheckPkgJSON",
    "onCheckCode",
    "onCheckConfig",
    "onBeforeMiddleware",
    "addBeforeMiddlewares",
    "addLayouts",
    "addMiddlewares",
    "addApiMiddlewares",
    "addRuntimePlugin",
    "addRuntimePluginKey",
    "addPolyfillImports",
    "addPrepareBuildPlugins",
    "addEntryImportsAhead",
    "addEntryImports",
    "addEntryCodeAhead",
    "addEntryCode",
    "addExtraBabelPresets",
    "addExtraBabelPlugins",
    "addBeforeBabelPresets",
    "addBeforeBabelPlugins",
    "addHTMLMetas",
    "addHTMLLinks",
    "addHTMLStyles",
    "addHTMLHeadScripts",
    "addHTMLScripts",
    "addTmpGenerateWatcherPaths",
    "addOnDemandDeps",
    "addUIModules",
    "chainWebpack",
    "modifyEntry",
    "modifyHTMLFavicon",
    "modifyHTML",
    "modifyExportHTMLFiles",
    "modifyWebpackConfig",
    "modifyViteConfig",
    "modifyRendererPath",
    "modifyServerRendererPath",
    "modifyRoutes",
    "modifyBabelPresetOpts",
    "modifyTSConfig",
    // support custom bundler
    "modifyUniBundler",
    "modifyUniBundlerOpts"
  ].forEach((name) => {
    api.registerMethod({ name });
  });
  api.onStart(async () => {
    await import_es_module_lexer.init;
  });
  const transformModule = (0, import_utils.importLazy)(
    require.resolve("./utils/transformIEAR")
  );
  api.registerMethod({
    name: "writeTmpFile",
    fn(opts) {
      (0, import_assert.default)(
        api.service.stage >= api.ServiceStage.runCommand,
        `api.writeTmpFile() should not execute in register stage.`
      );
      const absPath = (0, import_path.join)(
        api.paths.absTmpPath,
        // @ts-ignore
        this.plugin.key && !opts.noPluginDir ? `plugin-${this.plugin.key}` : "",
        opts.path
      );
      import_utils.fsExtra.mkdirpSync((0, import_path.dirname)(absPath));
      let content = opts.content;
      if (!content) {
        (0, import_assert.default)(
          !opts.tplPath || (0, import_fs.existsSync)(opts.tplPath) && (0, import_fs.statSync)(opts.tplPath).isFile(),
          `opts.tplPath does not exists or is not a file.`
        );
        const tpl = opts.tplPath ? (0, import_fs.readFileSync)(opts.tplPath, "utf-8") : opts.tpl;
        (0, import_assert.default)(tpl, `opts.tpl or opts.tplPath must be supplied.`);
        (0, import_assert.default)(
          import_utils.lodash.isPlainObject(opts.context),
          `opts.context must be plain object.`
        );
        content = import_utils.Mustache.render(tpl, opts.context);
      }
      const isJsFile = /\.(t|j)sx?$/.test(absPath);
      content = [
        (0, import_isTypeScriptFile.isTypeScriptFile)(opts.path) && `// @ts-nocheck`,
        isJsFile && "// This file is generated by Umi automatically",
        isJsFile && "// DO NOT CHANGE IT MANUALLY!",
        content.trim(),
        ""
      ].filter((text) => text !== false).join("\n");
      if (api.appData.vite && isJsFile) {
        const transformIEAR = transformModule.default;
        content = transformIEAR({ content, path: absPath }, api);
      }
      if (!(0, import_fs.existsSync)(absPath)) {
        (0, import_fs.writeFileSync)(absPath, content, "utf-8");
      } else {
        const fileContent = (0, import_fs.readFileSync)(absPath, "utf-8");
        if (fileContent.startsWith("// debug") || fileContent === content) {
          return;
        } else {
          (0, import_fs.writeFileSync)(absPath, content, "utf-8");
        }
      }
    }
  });
};
