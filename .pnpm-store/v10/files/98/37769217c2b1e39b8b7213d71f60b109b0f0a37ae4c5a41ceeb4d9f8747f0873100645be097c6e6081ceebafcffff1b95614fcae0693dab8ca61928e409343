{"version":3,"file":"constants.js","sourceRoot":"","sources":["../../source/core/constants.ts"],"names":[],"mappings":"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","sourcesContent":["import type {Expect, Equal} from '@type-challenges/utils';\nimport {type HttpMethod, type KyOptionsRegistry} from '../types/options.js';\n\nexport const supportsRequestStreams = (() => {\n\tlet duplexAccessed = false;\n\tlet hasContentType = false;\n\tconst supportsReadableStream = typeof globalThis.ReadableStream === 'function';\n\tconst supportsRequest = typeof globalThis.Request === 'function';\n\n\tif (supportsReadableStream && supportsRequest) {\n\t\ttry {\n\t\t\thasContentType = new globalThis.Request('https://empty.invalid', {\n\t\t\t\tbody: new globalThis.ReadableStream(),\n\t\t\t\tmethod: 'POST',\n\t\t\t\t// @ts-expect-error - Types are outdated.\n\t\t\t\tget duplex() {\n\t\t\t\t\tduplexAccessed = true;\n\t\t\t\t\treturn 'half';\n\t\t\t\t},\n\t\t\t}).headers.has('Content-Type');\n\t\t} catch (error) {\n\t\t\t// QQBrowser on iOS throws \"unsupported BodyInit type\" error (see issue #581)\n\t\t\tif (error instanceof Error && error.message === 'unsupported BodyInit type') {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\treturn duplexAccessed && !hasContentType;\n})();\n\nexport const supportsAbortController = typeof globalThis.AbortController === 'function';\nexport const supportsAbortSignal = typeof globalThis.AbortSignal === 'function' && typeof globalThis.AbortSignal.any === 'function';\nexport const supportsResponseStreams = typeof globalThis.ReadableStream === 'function';\nexport const supportsFormData = typeof globalThis.FormData === 'function';\n\nexport const requestMethods = ['get', 'post', 'put', 'patch', 'head', 'delete'] as const;\n\nconst validate = <T extends Array<true>>() => undefined as unknown as T;\nvalidate<[\n\tExpect<Equal<typeof requestMethods[number], HttpMethod>>,\n]>();\n\nexport const responseTypes = {\n\tjson: 'application/json',\n\ttext: 'text/*',\n\tformData: 'multipart/form-data',\n\tarrayBuffer: '*/*',\n\tblob: '*/*',\n\t// Supported in modern Fetch implementations (for example, browsers and recent Node.js/undici).\n\t// We still feature-check at runtime before exposing the shortcut.\n\tbytes: '*/*',\n} as const;\n\n// The maximum value of a 32bit int (see issue #117)\nexport const maxSafeTimeout = 2_147_483_647;\n\n// Size in bytes of a typical form boundary, used to help estimate upload size\nexport const usualFormBoundarySize = new TextEncoder().encode('------WebKitFormBoundaryaxpyiPgbbPti10Rw').length;\n\nexport const stop = Symbol('stop');\n\n/**\nOptions for forcing a retry via `ky.retry()`.\n*/\nexport type ForceRetryOptions = {\n\t/**\n\tCustom delay in milliseconds before retrying.\n\n\tIf not provided, uses the default retry delay calculation based on `retry.delay` configuration.\n\n\t**Note:** Custom delays bypass jitter and `backoffLimit`. This is intentional, as custom delays often come from server responses (e.g., `Retry-After` headers) and should be respected exactly as specified.\n\t*/\n\tdelay?: number;\n\n\t/**\n\tError code for the retry.\n\n\tThis machine-readable identifier will be included in the error message passed to `beforeRetry` hooks, allowing you to distinguish between different types of forced retries.\n\n\t@example\n\t```\n\treturn ky.retry({code: 'RATE_LIMIT'});\n\t// Resulting error message: 'Forced retry: RATE_LIMIT'\n\t```\n\t*/\n\tcode?: string;\n\n\t/**\n\tOriginal error that caused the retry.\n\n\tThis allows you to preserve the error chain when forcing a retry based on caught exceptions. The error will be set as the `cause` of the `ForceRetryError`, enabling proper error chain traversal.\n\n\t@example\n\t```\n\ttry {\n\t\tconst data = await response.clone().json();\n\t\tvalidateBusinessLogic(data);\n\t} catch (error) {\n\t\treturn ky.retry({\n\t\t\tcode: 'VALIDATION_FAILED',\n\t\t\tcause: error  // Preserves original error in chain\n\t\t});\n\t}\n\t```\n\t*/\n\tcause?: Error;\n\n\t/**\n\tCustom request to use for the retry.\n\n\tThis allows you to modify or completely replace the request during a forced retry. The custom request becomes the starting point for the retry - `beforeRetry` hooks can still further modify it if needed.\n\n\t**Note:** The custom request's `signal` will be replaced with Ky's managed signal to handle timeouts and user-provided abort signals correctly. If the original request body has been consumed, you must provide a new body or clone the request before consuming.\n\n\t@example\n\t```\n\t// Fallback to a different endpoint\n\treturn ky.retry({\n\t\trequest: new Request('https://backup-api.com/endpoint', {\n\t\t\tmethod: request.method,\n\t\t\theaders: request.headers,\n\t\t}),\n\t\tcode: 'BACKUP_ENDPOINT'\n\t});\n\n\t// Retry with refreshed authentication token\n\tconst data = await response.clone().json();\n\treturn ky.retry({\n\t\trequest: new Request(request, {\n\t\t\theaders: {\n\t\t\t\t...Object.fromEntries(request.headers),\n\t\t\t\t'Authorization': `Bearer ${data.newToken}`\n\t\t\t}\n\t\t}),\n\t\tcode: 'TOKEN_REFRESHED'\n\t});\n\t```\n\t*/\n\trequest?: Request;\n};\n\n/**\nMarker returned by ky.retry() to signal a forced retry from afterResponse hooks.\n*/\nexport class RetryMarker {\n\tconstructor(public options?: ForceRetryOptions) {}\n}\n\n/**\nForce a retry from an `afterResponse` hook.\n\nThis allows you to retry a request based on the response content, even if the response has a successful status code. The retry will respect the `retry.limit` option and skip the `shouldRetry` check. The forced retry is observable in `beforeRetry` hooks, where the error will be a `ForceRetryError`.\n\n@param options - Optional configuration for the retry.\n\n@example\n```\nimport ky, {isForceRetryError} from 'ky';\n\nconst api = ky.extend({\n\thooks: {\n\t\tafterResponse: [\n\t\t\tasync (request, options, response) => {\n\t\t\t\t// Retry based on response body content\n\t\t\t\tif (response.status === 200) {\n\t\t\t\t\tconst data = await response.clone().json();\n\n\t\t\t\t\t// Simple retry with default delay\n\t\t\t\t\tif (data.error?.code === 'TEMPORARY_ERROR') {\n\t\t\t\t\t\treturn ky.retry();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Retry with custom delay from API response\n\t\t\t\t\tif (data.error?.code === 'RATE_LIMIT') {\n\t\t\t\t\t\treturn ky.retry({\n\t\t\t\t\t\t\tdelay: data.error.retryAfter * 1000,\n\t\t\t\t\t\t\tcode: 'RATE_LIMIT'\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t// Retry with a modified request (e.g., fallback endpoint)\n\t\t\t\t\tif (data.error?.code === 'FALLBACK_TO_BACKUP') {\n\t\t\t\t\t\treturn ky.retry({\n\t\t\t\t\t\t\trequest: new Request('https://backup-api.com/endpoint', {\n\t\t\t\t\t\t\t\tmethod: request.method,\n\t\t\t\t\t\t\t\theaders: request.headers,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\tcode: 'BACKUP_ENDPOINT'\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t// Retry with refreshed authentication\n\t\t\t\t\tif (data.error?.code === 'TOKEN_REFRESH' && data.newToken) {\n\t\t\t\t\t\treturn ky.retry({\n\t\t\t\t\t\t\trequest: new Request(request, {\n\t\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t\t...Object.fromEntries(request.headers),\n\t\t\t\t\t\t\t\t\t'Authorization': `Bearer ${data.newToken}`\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\tcode: 'TOKEN_REFRESHED'\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t// Retry with cause to preserve error chain\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvalidateResponse(data);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\treturn ky.retry({\n\t\t\t\t\t\t\tcode: 'VALIDATION_FAILED',\n\t\t\t\t\t\t\tcause: error\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\tbeforeRetry: [\n\t\t\t({error, retryCount}) => {\n\t\t\t\t// Observable in beforeRetry hooks\n\t\t\t\tif (isForceRetryError(error)) {\n\t\t\t\t\tconsole.log(`Forced retry #${retryCount}: ${error.message}`);\n\t\t\t\t\t// Example output: \"Forced retry #1: Forced retry: RATE_LIMIT\"\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t}\n});\n\nconst response = await api.get('https://example.com/api');\n```\n*/\nexport const retry = (options?: ForceRetryOptions) => new RetryMarker(options);\n\nexport const kyOptionKeys: KyOptionsRegistry = {\n\tjson: true,\n\tparseJson: true,\n\tstringifyJson: true,\n\tsearchParams: true,\n\tprefixUrl: true,\n\tretry: true,\n\ttimeout: true,\n\thooks: true,\n\tthrowHttpErrors: true,\n\tonDownloadProgress: true,\n\tonUploadProgress: true,\n\tfetch: true,\n\tcontext: true,\n};\n\n// Vendor-specific fetch options that should always be passed to fetch()\n// even if they appear on the Request object due to vendor patching.\n// See: https://github.com/sindresorhus/ky/issues/541\nexport const vendorSpecificOptions = {\n\tnext: true, // Next.js cache revalidation (revalidate, tags)\n} as const;\n\n// Standard RequestInit options that should NOT be passed separately to fetch()\n// because they're already applied to the Request object.\n// Note: `dispatcher` and `priority` are NOT included here - they're fetch-only\n// options that the Request constructor doesn't accept, so they need to be passed\n// separately to fetch().\nexport const requestOptionsRegistry = {\n\tmethod: true,\n\theaders: true,\n\tbody: true,\n\tmode: true,\n\tcredentials: true,\n\tcache: true,\n\tredirect: true,\n\treferrer: true,\n\treferrerPolicy: true,\n\tintegrity: true,\n\tkeepalive: true,\n\tsignal: true,\n\twindow: true,\n\tduplex: true,\n} as const;\n"]}