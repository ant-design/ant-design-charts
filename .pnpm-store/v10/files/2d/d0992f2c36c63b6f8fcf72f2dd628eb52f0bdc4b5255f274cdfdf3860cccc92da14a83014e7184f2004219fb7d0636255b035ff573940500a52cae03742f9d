{"version":3,"file":"declaration.js","sourceRoot":"","sources":["../../../../src/lib/converter/factories/declaration.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\n\nimport { ContainerReflection, DeclarationReflection, ReflectionFlag, ReflectionKind } from '../../models/index';\nimport { Context } from '../context';\nimport { Converter } from '../converter';\nimport { getRawComment } from './comment.js';\nimport { createReferenceType } from './reference';\n\n/**\n * List of reflection kinds that never should be static.\n */\nconst nonStaticKinds = [\n    ReflectionKind.Class,\n    ReflectionKind.Interface,\n    ReflectionKind.Namespace\n];\n\n/**\n * List of ts kinds leading to none static merge.\n */\nconst nonStaticMergeKinds = [\n    ts.SyntaxKind.ClassDeclaration,\n    ts.SyntaxKind.ClassExpression,\n    ts.SyntaxKind.InterfaceDeclaration\n];\n\nconst builtInSymbolRegExp = /^__@(\\w+)$/;\n\nfunction hasCommentOnParentAxis (node: ts.Node): boolean {\n    let currentNode: ts.Node = node;\n\n    while (currentNode) {\n        if (Boolean(getRawComment(currentNode))) { return true; }\n\n        currentNode = currentNode.parent;\n    }\n\n    return false;\n}\n\nfunction shouldBeIgnoredAsNotDocumented (node: ts.Declaration, kind: ReflectionKind): boolean {\n    // never ignore modules, global, and enum members\n    if (kind === ReflectionKind.Module || kind === ReflectionKind.Global || kind === ReflectionKind.EnumMember) {\n        return false;\n    }\n\n    // do not ignore properties of the object types, that has comment themselves, for example\n    //\n    // /**\n    //  * has docs\n    //  */\n    //  export SomeType = { prop1 : string }\n    //\n    // same applies to the inline types for function arguments:\n    //\n    // function someFunc(arg1 : { prop1 : string, prop2 : number }) {...}\n    //\n    // The `prop1` from above should be included in the docs, even that it has no documentation\n    // Note, that this does not seem to apply to classes and interfaces - for those, even the class/interface\n    // has docs, we still want to exclude the undocumented properties\n    // Thankfully for object literals the kind of properties seems to be set to ReflectionKind.Variable\n    if (kind === ReflectionKind.Variable && hasCommentOnParentAxis(node)) {\n        return false;\n    }\n\n    const hasComment: boolean = Boolean(getRawComment(node));\n\n    return !hasComment;\n}\n\n/**\n * Create a declaration reflection from the given TypeScript node.\n *\n * @param context  The context object describing the current state the converter is in. The\n *   scope of the context will be the parent of the generated reflection.\n * @param node  The TypeScript node that should be converted to a reflection.\n * @param kind  The desired kind of the reflection.\n * @param name  The desired name of the reflection.\n * @returns The resulting reflection or undefined if an error is encountered.\n */\nexport function createDeclaration(context: Context, node: ts.Declaration, kind: ReflectionKind, name?: string): DeclarationReflection | undefined {\n    if (!(context.scope instanceof ContainerReflection)) {\n        throw new Error('Expected container reflection.');\n    }\n    const container = context.scope;\n\n    // Ensure we have a name for the reflection\n    if (!name) {\n        if (node.localSymbol) {\n            name = node.localSymbol.name;\n        } else if (node.symbol) {\n            name = node.symbol.name;\n        } else {\n            return;\n        }\n\n        // rename built-in symbols\n        const match = builtInSymbolRegExp.exec(name);\n        if (match) {\n            name = `[Symbol.${match[1]}]`;\n        } else if (kind & (ReflectionKind.ClassMember | ReflectionKind.VariableOrProperty) && name === '__computed') {\n            // rename computed properties\n            const declName = ts.getNameOfDeclaration(node);\n            const symbol = declName && context.checker.getSymbolAtLocation(declName);\n            if (symbol) {\n                name = context.checker.symbolToString(symbol, /*enclosingDeclaration*/ undefined, ts.SymbolFlags.ClassMember);\n            } else if (declName) {\n                name = declName.getText();\n            }\n        }\n    }\n\n    const modifiers = ts.getCombinedModifierFlags(node);\n\n    // Test whether the node is exported\n    let isExported: boolean;\n    if (kind === ReflectionKind.Module || kind === ReflectionKind.Global) {\n        isExported = true;\n    } else if (container.kind === ReflectionKind.Global) {\n        // In file mode, everything is exported.\n        isExported = true;\n    } else if (container.kindOf([ReflectionKind.Namespace, ReflectionKind.Module])) {\n        const symbol = context.getSymbolAtLocation(node);\n        if (!symbol) {\n            isExported = false;\n        } else {\n            let parentNode = node.parent;\n            while (![ts.SyntaxKind.SourceFile, ts.SyntaxKind.ModuleDeclaration].includes(parentNode.kind)) {\n                parentNode = parentNode.parent;\n            }\n            const parentSymbol = context.getSymbolAtLocation(parentNode);\n            if (!parentSymbol) {\n                // This is a file with no imports/exports, so everything is\n                // global and therefore exported.\n                isExported = true;\n            } else {\n                isExported = !!parentSymbol.exports?.get(symbol.escapedName);\n            }\n        }\n    } else {\n        isExported = container.flags.isExported;\n    }\n\n    if (\n        (!isExported && context.converter.excludeNotExported)\n        ||\n        (context.converter.excludeNotDocumented && shouldBeIgnoredAsNotDocumented(node, kind))\n    ) {\n        return;\n    }\n\n    // Test whether the node is private, when inheriting ignore private members\n    const isPrivate = !!(modifiers & ts.ModifierFlags.Private);\n    if (context.isInherit && isPrivate) {\n        return;\n    }\n\n    // Test whether the node is static, when merging a module to a class make the node static\n    let isConstructorProperty = false;\n    let isStatic = false;\n    if (!nonStaticKinds.includes(kind)) {\n        isStatic = !!(modifiers & ts.ModifierFlags.Static);\n        if (container.kind === ReflectionKind.Class) {\n            if (node.parent && node.parent.kind === ts.SyntaxKind.Constructor) {\n                isConstructorProperty = true;\n            } else if (!node.parent || !nonStaticMergeKinds.includes(node.parent.kind)) {\n                isStatic = true;\n            }\n        }\n    }\n\n    // Check if we already have a child of the same kind, with the same name and static flag\n    let child: DeclarationReflection | undefined;\n    const children = container.children = container.children || [];\n    children.forEach((n: DeclarationReflection) => {\n        if (n.name === name && n.flags.isStatic === isStatic && canMergeReflectionsByKind(n.kind, kind)) {\n            child = n;\n        }\n    });\n\n    if (!child) {\n        // Child does not exist, create a new reflection\n        child = new DeclarationReflection(name, kind, container);\n        child.setFlag(ReflectionFlag.Static, isStatic);\n        child.setFlag(ReflectionFlag.Private, isPrivate);\n        child.setFlag(ReflectionFlag.ConstructorProperty, isConstructorProperty);\n        child.setFlag(ReflectionFlag.Exported,  isExported);\n        child = setupDeclaration(context, child, node);\n\n        if (child) {\n            children.push(child);\n            context.registerReflection(child, context.getSymbolAtLocation(node) ?? node.symbol);\n        }\n    } else {\n        // Merge the existent reflection with the given node\n        child = mergeDeclarations(context, child, node, kind);\n    }\n\n    // If we have a reflection, trigger the corresponding event\n    if (child) {\n        context.trigger(Converter.EVENT_CREATE_DECLARATION, child, node);\n    }\n\n    return child;\n}\n\n/**\n * Setup a newly created declaration reflection.\n *\n * @param context  The context object describing the current state the converter is in.\n * @param reflection  The newly created blank reflection.\n * @param node  The TypeScript node whose properties should be applies to the given reflection.\n * @returns The reflection populated with the values of the given node.\n */\nfunction setupDeclaration(context: Context, reflection: DeclarationReflection, node: ts.Declaration) {\n    const modifiers = ts.getCombinedModifierFlags(node);\n\n    reflection.setFlag(ReflectionFlag.External,  context.isExternal);\n    reflection.setFlag(ReflectionFlag.Protected, !!(modifiers & ts.ModifierFlags.Protected));\n    reflection.setFlag(ReflectionFlag.Public,    !!(modifiers & ts.ModifierFlags.Public));\n    reflection.setFlag(ReflectionFlag.Optional,  !!(node['questionToken']));\n    reflection.setFlag(ReflectionFlag.Readonly,  !!(modifiers & ts.ModifierFlags.Readonly));\n\n    if (\n        context.isInherit &&\n        (node.parent === context.inheritParent || reflection.flags.isConstructorProperty)\n    ) {\n        if (!reflection.inheritedFrom) {\n            reflection.inheritedFrom = createReferenceType(context, node.symbol, true);\n            reflection.getAllSignatures().forEach((signature) => {\n                signature.inheritedFrom = createReferenceType(context, node.symbol, true);\n            });\n        }\n    }\n\n    return reflection;\n}\n\n// we should not be merging type and value with the same name,\n// because TypeScript has different namespaces for these two categories\nfunction canMergeReflectionsByKind(kind1: ReflectionKind, kind2: ReflectionKind): boolean {\n    if (\n        (kind1 & ReflectionKind.SomeType && kind2 & ReflectionKind.SomeValue)\n        ||\n        (kind2 & ReflectionKind.SomeType && kind1 & ReflectionKind.SomeValue)\n    ) {\n        return false;\n    }\n\n    return true;\n}\n\n/**\n * Merge the properties of the given TypeScript node with the pre existent reflection.\n *\n * @param context  The context object describing the current state the converter is in.\n * @param reflection  The pre existent reflection.\n * @param node  The TypeScript node whose properties should be merged with the given reflection.\n * @param kind  The desired kind of the reflection.\n * @returns The reflection merged with the values of the given node or NULL if the merge is invalid.\n */\nfunction mergeDeclarations(context: Context, reflection: DeclarationReflection, node: ts.Node, kind: ReflectionKind) {\n    if (reflection.kind !== kind) {\n        const weights = [ReflectionKind.Namespace, ReflectionKind.Enum, ReflectionKind.Class];\n        const kindWeight = weights.indexOf(kind);\n        const childKindWeight = weights.indexOf(reflection.kind);\n        if (kindWeight > childKindWeight) {\n            reflection.kind = kind;\n        }\n    }\n\n    if (\n        context.isInherit &&\n        (context.inherited || []).includes(reflection.name) &&\n        (node.parent === context.inheritParent || reflection.flags.isConstructorProperty)\n    ) {\n        if (!reflection.overwrites) {\n            reflection.overwrites = createReferenceType(context, node.symbol, true);\n            reflection.getAllSignatures().forEach((signature) => {\n                signature.overwrites = createReferenceType(context, node.symbol, true);\n            });\n        }\n        return;\n    }\n\n    return reflection;\n}\n"]}