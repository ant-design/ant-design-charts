{"version":3,"file":"index.umd.min.js","sources":["../../../node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../../../node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../../../node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../../../node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../../../node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../../../node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../../../node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../../../node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../../../node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../../../node_modules/.pnpm/@babel+runtime@7.28.4/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../src/util.ts","../src/ellipse.ts","../src/arc.ts","../../../node_modules/.pnpm/@antv+util@3.3.11/node_modules/@antv/util/esm/lodash/is-number-equal.js","../../../node_modules/.pnpm/gl-matrix@3.4.4/node_modules/gl-matrix/esm/common.js","../../../node_modules/.pnpm/gl-matrix@3.4.4/node_modules/gl-matrix/esm/vec2.js","../src/bezier.ts","../src/line.ts","../src/cubic.ts","../src/segments.ts","../src/polyline.ts","../src/polygon.ts","../src/quadratic.ts"],"sourcesContent":["function _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nexport { _arrayLikeToArray as default };","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? arrayLikeToArray(r, a) : void 0;\n  }\n}\nexport { _unsupportedIterableToArray as default };","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nfunction _slicedToArray(r, e) {\n  return arrayWithHoles(r) || iterableToArrayLimit(r, e) || unsupportedIterableToArray(r, e) || nonIterableRest();\n}\nexport { _slicedToArray as default };","function _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\nexport { _arrayWithHoles as default };","function _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nexport { _iterableToArrayLimit as default };","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nexport { _nonIterableRest as default };","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nfunction _toConsumableArray(r) {\n  return arrayWithoutHoles(r) || iterableToArray(r) || unsupportedIterableToArray(r) || nonIterableSpread();\n}\nexport { _toConsumableArray as default };","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return arrayLikeToArray(r);\n}\nexport { _arrayWithoutHoles as default };","function _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nexport { _iterableToArray as default };","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nexport { _nonIterableSpread as default };","import type { BBox } from './types';\n\nexport function distance(x1: number, y1: number, x2: number, y2: number) {\n  const dx = x1 - x2;\n  const dy = y1 - y2;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport function getBBoxByArray(xArr: number[], yArr: number[]): BBox {\n  const minX = Math.min(...xArr);\n  const minY = Math.min(...yArr);\n  const maxX = Math.max(...xArr);\n  const maxY = Math.max(...yArr);\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY,\n  };\n}\n\nexport function getBBoxRange(x1: number, y1: number, x2: number, y2: number) {\n  return {\n    minX: Math.min(x1, x2),\n    maxX: Math.max(x1, x2),\n    minY: Math.min(y1, y2),\n    maxY: Math.max(y1, y2),\n  };\n}\n\nexport function piMod(angle: number) {\n  return (angle + Math.PI * 2) % (Math.PI * 2);\n}\n","import type { BBox, Point } from './types';\nimport { distance, piMod } from './util';\n\nfunction copysign(v1: number, v2: number) {\n  const absv = Math.abs(v1);\n  return v2 > 0 ? absv : absv * -1;\n}\n\nexport function box(x: number, y: number, rx: number, ry: number): BBox {\n  return {\n    x: x - rx,\n    y: y - ry,\n    width: rx * 2,\n    height: ry * 2,\n  };\n}\nexport function length(x: number, y: number, rx: number, ry: number) {\n  return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));\n}\nexport function nearestPoint(\n  x: number,\n  y: number,\n  rx: number,\n  ry: number,\n  x0: number,\n  y0: number,\n) {\n  const a = rx;\n  const b = ry;\n  // 假如椭圆半径为0则返回圆心\n  if (a === 0 || b === 0) {\n    return {\n      x,\n      y,\n    };\n  }\n  // 转换成 0， 0 为中心的椭圆计算\n  const relativeX = x0 - x;\n  const relativeY = y0 - y;\n  const px = Math.abs(relativeX);\n  const py = Math.abs(relativeY);\n  const squareA = a * a;\n  const squareB = b * b;\n  // const angle0 = Math.atan2(relativeY, relativeX);\n  let t = Math.PI / 4;\n  let nearestX = 0; // 椭圆上的任一点\n  let nearestY = 0;\n  // 迭代 4 次\n  for (let i = 0; i < 4; i++) {\n    nearestX = a * Math.cos(t);\n    nearestY = b * Math.sin(t);\n\n    const ex = ((squareA - squareB) * Math.cos(t) ** 3) / a;\n    const ey = ((squareB - squareA) * Math.sin(t) ** 3) / b;\n    const rx1 = nearestX - ex;\n    const ry1 = nearestY - ey;\n\n    const qx = px - ex;\n    const qy = py - ey;\n    const r = Math.hypot(ry1, rx1);\n    const q = Math.hypot(qy, qx);\n\n    const delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));\n    const delta_t =\n      delta_c /\n      Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);\n\n    t += delta_t;\n    t = Math.min(Math.PI / 2, Math.max(0, t));\n  }\n\n  return {\n    x: x + copysign(nearestX, relativeX),\n    y: y + copysign(nearestY, relativeY),\n  };\n}\nexport function pointDistance(\n  x: number,\n  y: number,\n  rx: number,\n  ry: number,\n  x0: number,\n  y0: number,\n) {\n  const np = nearestPoint(x, y, rx, ry, x0, y0);\n  return distance(np.x, np.y, x0, y0);\n}\nexport function pointAt(\n  x: number,\n  y: number,\n  rx: number,\n  ry: number,\n  t: number,\n): Point {\n  const angle = 2 * Math.PI * t; // 按照角度进行计算，而不按照周长计算\n  return {\n    x: x + rx * Math.cos(angle),\n    y: y + ry * Math.sin(angle),\n  };\n}\nexport function tangentAngle(\n  x: number,\n  y: number,\n  rx: number,\n  ry: number,\n  t: number,\n) {\n  const angle = 2 * Math.PI * t; // 按照角度进行计算，而不按照周长计算\n  // 直接使用 x,y 的导数计算， x' = -rx * sin(t); y' = ry * cos(t);\n  const tangentAngle = Math.atan2(ry * Math.cos(angle), -rx * Math.sin(angle));\n  // 也可以使用指定点的切线方程计算，成本有些高\n  // const point = this.pointAt(0, 0, rx, ry, t); // 椭圆的切线同椭圆的中心不相关\n  // let tangentAngle = -1 * Math.atan((ry * ry * point.x) / (rx * rx * point.y));\n  // if (angle >= 0 && angle <= Math.PI) {\n  //   tangentAngle += Math.PI;\n  // }\n\n  return piMod(tangentAngle);\n}\n","import { nearestPoint as ellipseNearestPoint } from './ellipse';\nimport type { BBox, Point } from './types';\nimport { distance, piMod } from './util';\n\n// 偏导数 x\nfunction derivativeXAt(\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  xRotation: number,\n  startAngle: number,\n  endAngle: number,\n  angle: number,\n) {\n  return (\n    -1 * rx * Math.cos(xRotation) * Math.sin(angle) -\n    ry * Math.sin(xRotation) * Math.cos(angle)\n  );\n}\n\n// 偏导数 y\nfunction derivativeYAt(\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  xRotation: number,\n  startAngle: number,\n  endAngle: number,\n  angle: number,\n) {\n  return (\n    -1 * rx * Math.sin(xRotation) * Math.sin(angle) +\n    ry * Math.cos(xRotation) * Math.cos(angle)\n  );\n}\n\n// x 的极值\nfunction xExtrema(rx: number, ry: number, xRotation: number) {\n  return Math.atan((-ry / rx) * Math.tan(xRotation));\n}\n\n// y 的极值\nfunction yExtrema(rx: number, ry: number, xRotation: number) {\n  return Math.atan(ry / (rx * Math.tan(xRotation)));\n}\n\n// 根据角度求 x 坐标\nfunction xAt(\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  xRotation: number,\n  angle: number,\n) {\n  return (\n    rx * Math.cos(xRotation) * Math.cos(angle) -\n    ry * Math.sin(xRotation) * Math.sin(angle) +\n    cx\n  );\n}\n\n// 根据角度求 y 坐标\nfunction yAt(\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  xRotation: number,\n  angle: number,\n) {\n  return (\n    rx * Math.sin(xRotation) * Math.cos(angle) +\n    ry * Math.cos(xRotation) * Math.sin(angle) +\n    cy\n  );\n}\n\n// 获取点在椭圆上的角度\nfunction getAngle(rx: number, ry: number, x0: number, y0: number) {\n  const angle = Math.atan2(y0 * rx, x0 * ry);\n  // 转换到 0 - 2PI 内\n  return (angle + Math.PI * 2) % (Math.PI * 2);\n}\n\n// 根据角度获取，x,y\nfunction getPoint(rx: number, ry: number, angle: number): Point {\n  return {\n    x: rx * Math.cos(angle),\n    y: ry * Math.sin(angle),\n  };\n}\n\n// 旋转\nfunction rotate(x: number, y: number, angle: number) {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  return [x * cos - y * sin, x * sin + y * cos];\n}\n\nexport function box(\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  xRotation: number,\n  startAngle: number,\n  endAngle: number,\n): BBox {\n  const xDim = xExtrema(rx, ry, xRotation);\n  let minX = Infinity;\n  let maxX = -Infinity;\n  const xs = [startAngle, endAngle];\n  for (let i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {\n    const xAngle = xDim + i;\n    if (startAngle < endAngle) {\n      if (startAngle < xAngle && xAngle < endAngle) {\n        xs.push(xAngle);\n      }\n    } else if (endAngle < xAngle && xAngle < startAngle) {\n      xs.push(xAngle);\n    }\n  }\n\n  for (let i = 0; i < xs.length; i++) {\n    const x = xAt(cx, cy, rx, ry, xRotation, xs[i]);\n    if (x < minX) {\n      minX = x;\n    }\n    if (x > maxX) {\n      maxX = x;\n    }\n  }\n\n  const yDim = yExtrema(rx, ry, xRotation);\n  let minY = Infinity;\n  let maxY = -Infinity;\n  const ys = [startAngle, endAngle];\n  for (let i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {\n    const yAngle = yDim + i;\n    if (startAngle < endAngle) {\n      if (startAngle < yAngle && yAngle < endAngle) {\n        ys.push(yAngle);\n      }\n    } else if (endAngle < yAngle && yAngle < startAngle) {\n      ys.push(yAngle);\n    }\n  }\n\n  for (let i = 0; i < ys.length; i++) {\n    const y = yAt(cx, cy, rx, ry, xRotation, ys[i]);\n    if (y < minY) {\n      minY = y;\n    }\n    if (y > maxY) {\n      maxY = y;\n    }\n  }\n\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY,\n  };\n}\n\nexport function nearestPoint(\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  xRotation: number,\n  startAngle: number,\n  endAngle: number,\n  x0: number,\n  y0: number,\n) {\n  // 将最近距离问题转换成到椭圆中心 0,0 没有旋转的椭圆问题\n  const relativeVector = rotate(x0 - cx, y0 - cy, -xRotation);\n  const [x1, y1] = relativeVector;\n  // 计算点到椭圆的最近的点\n  let relativePoint = ellipseNearestPoint(0, 0, rx, ry, x1, y1);\n  // 获取点在椭圆上的角度\n  const angle = getAngle(rx, ry, relativePoint.x, relativePoint.y);\n  // 点没有在圆弧上\n  if (angle < startAngle) {\n    // 小于起始圆弧\n    relativePoint = getPoint(rx, ry, startAngle);\n  } else if (angle > endAngle) {\n    // 大于结束圆弧\n    relativePoint = getPoint(rx, ry, endAngle);\n  }\n  // 旋转到 xRotation 的角度\n  const vector = rotate(relativePoint.x, relativePoint.y, xRotation);\n  return {\n    x: vector[0] + cx,\n    y: vector[1] + cy,\n  };\n}\n\nexport function pointDistance(\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  xRotation: number,\n  startAngle: number,\n  endAngle: number,\n  x0: number,\n  y0: number,\n) {\n  const np = nearestPoint(\n    cx,\n    cy,\n    rx,\n    ry,\n    xRotation,\n    startAngle,\n    endAngle,\n    x0,\n    y0,\n  );\n  return distance(np.x, np.y, x0, y0);\n}\n\nexport function pointAt(\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  xRotation: number,\n  startAngle: number,\n  endAngle: number,\n  t: number,\n): Point {\n  const angle = (endAngle - startAngle) * t + startAngle;\n  return {\n    x: xAt(cx, cy, rx, ry, xRotation, angle),\n    y: yAt(cx, cy, rx, ry, xRotation, angle),\n  };\n}\n\nexport function tangentAngle(\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  xRotation: number,\n  startAngle: number,\n  endAngle: number,\n  t: number,\n) {\n  const angle = (endAngle - startAngle) * t + startAngle;\n  const dx = derivativeXAt(\n    cx,\n    cy,\n    rx,\n    ry,\n    xRotation,\n    startAngle,\n    endAngle,\n    angle,\n  );\n  const dy = derivativeYAt(\n    cx,\n    cy,\n    rx,\n    ry,\n    xRotation,\n    startAngle,\n    endAngle,\n    angle,\n  );\n  return piMod(Math.atan2(dy, dx));\n}\n","var PRECISION = 0.00001; // numbers less than this is considered as 0\n/**\n * 判断两个数是否相等\n * @return 是否相等\n */\nexport default function isNumberEqual(a, b, precision) {\n    if (precision === void 0) { precision = PRECISION; }\n    return a === b || Math.abs(a - b) < precision;\n}\n//# sourceMappingURL=is-number-equal.js.map","/**\n * Common utilities\n * @module glMatrix\n */\n\n// Configuration Constants\nexport var EPSILON = 0.000001;\nexport var ARRAY_TYPE = typeof Float32Array !== \"undefined\" ? Float32Array : Array;\nexport var RANDOM = Math.random;\nexport var ANGLE_ORDER = \"zyx\";\n\n/**\n * Symmetric round\n * see https://www.npmjs.com/package/round-half-up-symmetric#user-content-detailed-background\n *\n * @param {Number} a value to round\n */\nexport function round(a) {\n  if (a >= 0) return Math.round(a);\n  return a % 0.5 === 0 ? Math.floor(a) : Math.round(a);\n}\n\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\n */\nexport function setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\nvar radian = 180 / Math.PI;\n\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\nexport function toRadian(a) {\n  return a * degree;\n}\n\n/**\n * Convert Radian To Degree\n *\n * @param {Number} a Angle in Radians\n */\nexport function toDegree(a) {\n  return a * radian;\n}\n\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a          The first number to test.\n * @param {Number} b          The second number to test.\n * @param {Number} tolerance  Absolute or relative tolerance (default glMatrix.EPSILON)\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\nexport function equals(a, b) {\n  var tolerance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EPSILON;\n  return Math.abs(a - b) <= tolerance * Math.max(1, Math.abs(a), Math.abs(b));\n}","import * as glMatrix from \"./common.js\";\n\n/**\n * 2 Dimensional Vector\n * @module vec2\n */\n\n/**\n * Creates a new, empty vec2\n *\n * @returns {vec2} a new 2D vector\n */\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n  }\n  return out;\n}\n\n/**\n * Creates a new vec2 initialized with values from an existing vector\n *\n * @param {ReadonlyVec2} a vector to clone\n * @returns {vec2} a new 2D vector\n */\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n\n/**\n * Creates a new vec2 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} a new 2D vector\n */\nexport function fromValues(x, y) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the source vector\n * @returns {vec2} out\n */\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\nexport function set(out, x, y) {\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  return out;\n}\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  return out;\n}\n\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  return out;\n}\n\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  return out;\n}\n\n/**\n * Math.ceil the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to ceil\n * @returns {vec2} out\n */\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  return out;\n}\n\n/**\n * Math.floor the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to floor\n * @returns {vec2} out\n */\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  return out;\n}\n\n/**\n * Returns the minimum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  return out;\n}\n\n/**\n * Returns the maximum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  return out;\n}\n\n/**\n * symmetric round the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to round\n * @returns {vec2} out\n */\nexport function round(out, a) {\n  out[0] = glMatrix.round(a[0]);\n  out[1] = glMatrix.round(a[1]);\n  return out;\n}\n\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  return out;\n}\n\n/**\n * Adds two vec2's after scaling the second operand by a scalar value\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec2} out\n */\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  return out;\n}\n\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} distance between a and b\n */\nexport function distance(a, b) {\n  var x = b[0] - a[0],\n    y = b[1] - a[1];\n  return Math.sqrt(x * x + y * y);\n}\n\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0],\n    y = b[1] - a[1];\n  return x * x + y * y;\n}\n\n/**\n * Calculates the length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport function length(a) {\n  var x = a[0],\n    y = a[1];\n  return Math.sqrt(x * x + y * y);\n}\n\n/**\n * Calculates the squared length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nexport function squaredLength(a) {\n  var x = a[0],\n    y = a[1];\n  return x * x + y * y;\n}\n\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to negate\n * @returns {vec2} out\n */\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  return out;\n}\n\n/**\n * Returns the inverse of the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to invert\n * @returns {vec2} out\n */\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n}\n\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to normalize\n * @returns {vec2} out\n */\nexport function normalize(out, a) {\n  var x = a[0],\n    y = a[1];\n  var len = x * x + y * y;\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  return out;\n}\n\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} dot product of a and b\n */\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product must by definition produce a 3D vector\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec3} out\n */\nexport function cross(out, a, b) {\n  var z = a[0] * b[1] - a[1] * b[0];\n  out[0] = out[1] = 0;\n  out[2] = z;\n  return out;\n}\n\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec2} out\n */\nexport function lerp(out, a, b, t) {\n  var ax = a[0],\n    ay = a[1];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  return out;\n}\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec2} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned\n * @returns {vec2} out\n */\nexport function random(out, scale) {\n  scale = scale === undefined ? 1.0 : scale;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  out[0] = Math.cos(r) * scale;\n  out[1] = Math.sin(r) * scale;\n  return out;\n}\n\n/**\n * Transforms the vec2 with a mat2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat2(out, a, m) {\n  var x = a[0],\n    y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  return out;\n}\n\n/**\n * Transforms the vec2 with a mat2d\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2d} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat2d(out, a, m) {\n  var x = a[0],\n    y = a[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat3} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n    y = a[1];\n  out[0] = m[0] * x + m[3] * y + m[6];\n  out[1] = m[1] * x + m[4] * y + m[7];\n  return out;\n}\n\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat4(out, a, m) {\n  var x = a[0];\n  var y = a[1];\n  out[0] = m[0] * x + m[4] * y + m[12];\n  out[1] = m[1] * x + m[5] * y + m[13];\n  return out;\n}\n\n/**\n * Rotate a 2D vector\n * @param {vec2} out The receiving vec2\n * @param {ReadonlyVec2} a The vec2 point to rotate\n * @param {ReadonlyVec2} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec2} out\n */\nexport function rotate(out, a, b, rad) {\n  //Translate point to the origin\n  var p0 = a[0] - b[0],\n    p1 = a[1] - b[1],\n    sinC = Math.sin(rad),\n    cosC = Math.cos(rad);\n\n  //perform rotation and translate to correct position\n  out[0] = p0 * cosC - p1 * sinC + b[0];\n  out[1] = p0 * sinC + p1 * cosC + b[1];\n  return out;\n}\n\n/**\n * Get the smallest angle between two 2D vectors\n * @param {ReadonlyVec2} a The first operand\n * @param {ReadonlyVec2} b The second operand\n * @returns {Number} The angle in radians\n */\nexport function angle(a, b) {\n  var ax = a[0],\n    ay = a[1],\n    bx = b[0],\n    by = b[1];\n  return Math.abs(Math.atan2(ay * bx - ax * by, ax * bx + ay * by));\n}\n\n/**\n * Get the signed angle in the interval [-pi,pi] between two 2D vectors (positive if `a` is to the right of `b`)\n * \n * @param {ReadonlyVec2} a The first vector\n * @param {ReadonlyVec2} b The second vector\n * @returns {number} The signed angle in radians\n */\nexport function signedAngle(a, b) {\n  var ax = a[0],\n    ay = a[1],\n    bx = b[0],\n    by = b[1];\n  return Math.atan2(ax * by - ay * bx, ax * bx + ay * by);\n}\n\n/**\n * Set the components of a vec2 to zero\n *\n * @param {vec2} out the receiving vector\n * @returns {vec2} out\n */\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  return out;\n}\n\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec2} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\nexport function str(a) {\n  return \"vec2(\" + a[0] + \", \" + a[1] + \")\";\n}\n\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport function equals(a, b) {\n  var a0 = a[0],\n    a1 = a[1];\n  var b0 = b[0],\n    b1 = b[1];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));\n}\n\n/**\n * Alias for {@link vec2.length}\n * @function\n */\nexport var len = length;\n\n/**\n * Alias for {@link vec2.subtract}\n * @function\n */\nexport var sub = subtract;\n\n/**\n * Alias for {@link vec2.multiply}\n * @function\n */\nexport var mul = multiply;\n\n/**\n * Alias for {@link vec2.divide}\n * @function\n */\nexport var div = divide;\n\n/**\n * Alias for {@link vec2.distance}\n * @function\n */\nexport var dist = distance;\n\n/**\n * Alias for {@link vec2.squaredDistance}\n * @function\n */\nexport var sqrDist = squaredDistance;\n\n/**\n * Alias for {@link vec2.squaredLength}\n * @function\n */\nexport var sqrLen = squaredLength;\n\n/**\n * Perform some operation over an array of vec2s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n    if (!stride) {\n      stride = 2;\n    }\n    if (!offset) {\n      offset = 0;\n    }\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n    }\n    return a;\n  };\n}();","import { distance } from './util';\nimport type { Point, PointTuple } from './types';\n\nconst EPSILON = 0.0001;\n/**\n * 使用牛顿切割法求最近的点\n * @param {number[]} xArr      点的 x 数组\n * @param {number[]} yArr      点的 y 数组\n * @param {number}   x         指定的点 x\n * @param {number}   y         指定的点 y\n * @param {Function} tCallback 差值函数\n */\nexport function nearestPoint(\n  xArr: number[],\n  yArr: number[],\n  x: number,\n  y: number,\n  tCallback: (...arr: number[]) => number,\n  length?: number,\n): Point {\n  let t = -1;\n  let d = Infinity;\n  const v0: PointTuple = [x, y];\n\n  let segNum = 20;\n  if (length && length > 200) {\n    segNum = length / 10;\n  }\n  const increaseRate = 1 / segNum;\n\n  let interval = increaseRate / 10;\n\n  for (let i = 0; i <= segNum; i++) {\n    const _t = i * increaseRate;\n    const v1: PointTuple = [\n      tCallback(...xArr.concat([_t])),\n      tCallback(...yArr.concat([_t])),\n    ];\n\n    const d1 = distance(v0[0], v0[1], v1[0], v1[1]);\n    if (d1 < d) {\n      t = _t;\n      d = d1;\n    }\n  }\n  // 提前终止\n  if (t === 0) {\n    return {\n      x: xArr[0],\n      y: yArr[0],\n    };\n  }\n  if (t === 1) {\n    const count = xArr.length;\n    return {\n      x: xArr[count - 1],\n      y: yArr[count - 1],\n    };\n  }\n  d = Infinity;\n\n  for (let i = 0; i < 32; i++) {\n    if (interval < EPSILON) {\n      break;\n    }\n\n    const prev = t - interval;\n    const next = t + interval;\n\n    const v1 = [\n      tCallback(...xArr.concat([prev])),\n      tCallback(...yArr.concat([prev])),\n    ];\n\n    const d1 = distance(v0[0], v0[1], v1[0], v1[1]);\n    if (prev >= 0 && d1 < d) {\n      t = prev;\n      d = d1;\n    } else {\n      const v2 = [\n        tCallback(...xArr.concat([next])),\n        tCallback(...yArr.concat([next])),\n      ];\n      const d2 = distance(v0[0], v0[1], v2[0], v2[1]);\n      if (next <= 1 && d2 < d) {\n        t = next;\n        d = d2;\n      } else {\n        interval *= 0.5;\n      }\n    }\n  }\n\n  return {\n    x: tCallback(...xArr.concat([t])),\n    y: tCallback(...yArr.concat([t])),\n  };\n}\n\n// 近似求解 https://community.khronos.org/t/3d-cubic-bezier-segment-length/62363/2\nexport function snapLength(xArr: number[], yArr: number[]) {\n  let totalLength = 0;\n  const count = xArr.length;\n  for (let i = 0; i < count; i++) {\n    const x = xArr[i];\n    const y = yArr[i];\n    const nextX = xArr[(i + 1) % count];\n    const nextY = yArr[(i + 1) % count];\n    totalLength += distance(x, y, nextX, nextY);\n  }\n  return totalLength / 2;\n}\n","import { vec2 } from 'gl-matrix';\nimport type { BBox, Point } from './types';\nimport { distance, getBBoxByArray } from './util';\n\nexport function box(x1: number, y1: number, x2: number, y2: number): BBox {\n  return getBBoxByArray([x1, x2], [y1, y2]);\n}\n\nexport function length(x1: number, y1: number, x2: number, y2: number) {\n  return distance(x1, y1, x2, y2);\n}\n\nexport function pointAt(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  t: number,\n): Point {\n  return {\n    x: (1 - t) * x1 + t * x2,\n    y: (1 - t) * y1 + t * y2,\n  };\n}\n\nexport function pointDistance(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x: number,\n  y: number,\n): number {\n  // 投影距离 x1, y1 的向量，假设 p, p1, p2 三个点，投影点为 a\n  // p1a = p1p.p1p2/|p1p2| * (p1p 的单位向量)\n  const cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);\n  if (cross < 0) {\n    return distance(x1, y1, x, y);\n  }\n  const lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n  if (cross > lengthSquare) {\n    return distance(x2, y2, x, y);\n  }\n  return pointToLine(x1, y1, x2, y2, x, y);\n}\n\nexport function pointToLine(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x: number,\n  y: number,\n) {\n  const d: [number, number] = [x2 - x1, y2 - y1];\n  // 如果端点相等，则判定点到点的距离\n  if (vec2.exactEquals(d, [0, 0])) {\n    return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\n  }\n  const u: [number, number] = [-d[1], d[0]];\n  vec2.normalize(u, u);\n  const a: [number, number] = [x - x1, y - y1];\n  return Math.abs(vec2.dot(a, u));\n}\n\nexport function tangentAngle(x1: number, y1: number, x2: number, y2: number) {\n  return Math.atan2(y2 - y1, x2 - x1);\n}\n","import { isNumberEqual } from '@antv/util';\nimport { nearestPoint as bezierNearestPoint, snapLength } from './bezier';\nimport { pointAt as linePointAt } from './line';\nimport type { Point } from './types';\nimport { distance, getBBoxByArray, piMod } from './util';\n\nfunction cubicAt(p0: number, p1: number, p2: number, p3: number, t: number) {\n  const onet = 1 - t; // t * t * t 的性能大概是 Math.pow(t, 3) 的三倍\n  return (\n    onet * onet * onet * p0 +\n    3 * p1 * t * onet * onet +\n    3 * p2 * t * t * onet +\n    p3 * t * t * t\n  );\n}\n\nfunction derivativeAt(\n  p0: number,\n  p1: number,\n  p2: number,\n  p3: number,\n  t: number,\n) {\n  const onet = 1 - t;\n  return (\n    3 * (onet * onet * (p1 - p0) + 2 * onet * t * (p2 - p1) + t * t * (p3 - p2))\n  );\n}\n\nfunction extrema(p0: number, p1: number, p2: number, p3: number) {\n  const a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;\n  const b = 6 * p0 - 12 * p1 + 6 * p2;\n  const c = 3 * p1 - 3 * p0;\n  const extremas = [];\n  let t1: number;\n  let t2: number;\n  let discSqrt: number;\n\n  if (isNumberEqual(a, 0)) {\n    if (!isNumberEqual(b, 0)) {\n      t1 = -c / b;\n      if (t1 >= 0 && t1 <= 1) {\n        extremas.push(t1);\n      }\n    }\n  } else {\n    const disc = b * b - 4 * a * c;\n    if (isNumberEqual(disc, 0)) {\n      extremas.push(-b / (2 * a));\n    } else if (disc > 0) {\n      discSqrt = Math.sqrt(disc);\n      t1 = (-b + discSqrt) / (2 * a);\n      t2 = (-b - discSqrt) / (2 * a);\n      if (t1 >= 0 && t1 <= 1) {\n        extremas.push(t1);\n      }\n      if (t2 >= 0 && t2 <= 1) {\n        extremas.push(t2);\n      }\n    }\n  }\n  return extremas;\n}\n\n// 分割贝塞尔曲线\nfunction divideCubic(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x4: number,\n  y4: number,\n  t: number,\n): [number, number, number, number, number, number, number, number][] {\n  // 划分点\n  const xt = cubicAt(x1, x2, x3, x4, t);\n  const yt = cubicAt(y1, y2, y3, y4, t);\n  // 计算两点之间的差值点\n  const c1 = linePointAt(x1, y1, x2, y2, t);\n  const c2 = linePointAt(x2, y2, x3, y3, t);\n  const c3 = linePointAt(x3, y3, x4, y4, t);\n  const c12 = linePointAt(c1.x, c1.y, c2.x, c2.y, t);\n  const c23 = linePointAt(c2.x, c2.y, c3.x, c3.y, t);\n  return [\n    [x1, y1, c1.x, c1.y, c12.x, c12.y, xt, yt],\n    [xt, yt, c23.x, c23.y, c3.x, c3.y, x4, y4],\n  ];\n}\n\n// 使用迭代法取贝塞尔曲线的长度，二阶和三阶分开写，更清晰和便于调试\nfunction cubicLength(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x4: number,\n  y4: number,\n  iterationCount: number,\n): number {\n  if (iterationCount === 0) {\n    return snapLength([x1, x2, x3, x4], [y1, y2, y3, y4]);\n  }\n  const cubics = divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, 0.5);\n  const left: [\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n  ] = [...cubics[0], iterationCount - 1];\n  const right: [\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n  ] = [...cubics[1], iterationCount - 1];\n  return cubicLength(...left) + cubicLength(...right);\n}\n\nexport function box(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x4: number,\n  y4: number,\n) {\n  const xArr = [x1, x4];\n  const yArr = [y1, y4];\n  const xExtrema = extrema(x1, x2, x3, x4);\n  const yExtrema = extrema(y1, y2, y3, y4);\n  for (let i = 0; i < xExtrema.length; i++) {\n    xArr.push(cubicAt(x1, x2, x3, x4, xExtrema[i]));\n  }\n  for (let i = 0; i < yExtrema.length; i++) {\n    yArr.push(cubicAt(y1, y2, y3, y4, yExtrema[i]));\n  }\n  return getBBoxByArray(xArr, yArr);\n}\n\nexport function length(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x4: number,\n  y4: number,\n) {\n  // 迭代三次，划分成 8 段求长度\n  return cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, 3);\n}\n\nexport function nearestPoint(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x4: number,\n  y4: number,\n  x0: number,\n  y0: number,\n  length?: number,\n) {\n  return bezierNearestPoint(\n    [x1, x2, x3, x4],\n    [y1, y2, y3, y4],\n    x0,\n    y0,\n    cubicAt,\n    length,\n  );\n}\n\nexport function pointDistance(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x4: number,\n  y4: number,\n  x0: number,\n  y0: number,\n  length?: number,\n) {\n  const point = nearestPoint(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length);\n  return distance(point.x, point.y, x0, y0);\n}\n\nexport function pointAt(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x4: number,\n  y4: number,\n  t: number,\n): Point {\n  return {\n    x: cubicAt(x1, x2, x3, x4, t),\n    y: cubicAt(y1, y2, y3, y4, t),\n  };\n}\n\nexport function divide(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x4: number,\n  y4: number,\n  t: number,\n) {\n  return divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t);\n}\n\nexport function tangentAngle(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x4: number,\n  y4: number,\n  t: number,\n) {\n  const dx = derivativeAt(x1, x2, x3, x4, t);\n  const dy = derivativeAt(y1, y2, y3, y4, t);\n  return piMod(Math.atan2(dy, dx));\n}\n","import { pointAt, pointDistance } from './line';\nimport type { Point, PointTuple, Segment } from './types';\nimport { distance } from './util';\n\nfunction analyzePoints(points: PointTuple[]) {\n  // 计算每段的长度和总的长度\n  let totalLength = 0;\n  const segments: Segment[] = [];\n  for (let i = 0; i < points.length - 1; i++) {\n    const from = points[i];\n    const to = points[i + 1];\n    const length = distance(from[0], from[1], to[0], to[1]);\n    const seg = {\n      from,\n      to,\n      length,\n    };\n    segments.push(seg);\n    totalLength += length;\n  }\n  return { segments, totalLength };\n}\n\nexport function lengthOfSegment(points: PointTuple[]) {\n  if (points.length < 2) {\n    return 0;\n  }\n  let totalLength = 0;\n  for (let i = 0; i < points.length - 1; i++) {\n    const from = points[i];\n    const to = points[i + 1];\n    totalLength += distance(from[0], from[1], to[0], to[1]);\n  }\n  return totalLength;\n}\n\n/**\n * 按照比例在数据片段中获取点\n * @param {array} points 点的集合\n * @param {number} t 百分比 0-1\n * @return {object} 点的坐标\n */\nexport function pointAtSegments(points: PointTuple[], t: number): Point | null {\n  // 边界判断\n  if (t > 1 || t < 0 || points.length < 2) {\n    return null;\n  }\n  const { segments, totalLength } = analyzePoints(points);\n  // 多个点有可能重合\n  if (totalLength === 0) {\n    return {\n      x: points[0][0],\n      y: points[0][1],\n    };\n  }\n  // 计算比例\n  let startRatio = 0;\n  let point = null;\n  for (let i = 0; i < segments.length; i++) {\n    const seg = segments[i];\n    const { from, to } = seg;\n    const currentRatio = seg.length / totalLength;\n    if (t >= startRatio && t <= startRatio + currentRatio) {\n      const localRatio = (t - startRatio) / currentRatio;\n      point = pointAt(from[0], from[1], to[0], to[1], localRatio);\n      break;\n    }\n    startRatio += currentRatio;\n  }\n  return point;\n}\n\n/**\n * 按照比例在数据片段中获取切线的角度\n * @param {array} points 点的集合\n * @param {number} t 百分比 0-1\n */\nexport function angleAtSegments(points: PointTuple[], t: number) {\n  // 边界判断\n  if (t > 1 || t < 0 || points.length < 2) {\n    return 0;\n  }\n  const { segments, totalLength } = analyzePoints(points);\n  // 计算比例\n  let startRatio = 0;\n  let angle = 0;\n  for (let i = 0; i < segments.length; i++) {\n    const seg = segments[i];\n    const { from, to } = seg;\n    const currentRatio = seg.length / totalLength;\n    if (t >= startRatio && t <= startRatio + currentRatio) {\n      angle = Math.atan2(to[1] - from[1], to[0] - from[0]);\n      break;\n    }\n    startRatio += currentRatio;\n  }\n  return angle;\n}\n\nexport function distanceAtSegment(points: PointTuple[], x: number, y: number) {\n  let minDistance = Infinity;\n  for (let i = 0; i < points.length - 1; i++) {\n    const point = points[i];\n    const nextPoint = points[i + 1];\n    const distance = pointDistance(\n      point[0],\n      point[1],\n      nextPoint[0],\n      nextPoint[1],\n      x,\n      y,\n    );\n    if (distance < minDistance) {\n      minDistance = distance;\n    }\n  }\n  return minDistance;\n}\n","import {\n  angleAtSegments,\n  distanceAtSegment,\n  lengthOfSegment,\n  pointAtSegments,\n} from './segments';\nimport type { BBox, PointTuple } from './types';\nimport { getBBoxByArray } from './util';\n\nexport function box(points: PointTuple[]): BBox {\n  const xArr = [];\n  const yArr = [];\n  for (let i = 0; i < points.length; i++) {\n    const point = points[i];\n    xArr.push(point[0]);\n    yArr.push(point[1]);\n  }\n  return getBBoxByArray(xArr, yArr);\n}\nexport function length(points: PointTuple[]) {\n  return lengthOfSegment(points);\n}\nexport function pointAt(points: PointTuple[], t: number) {\n  return pointAtSegments(points, t);\n}\nexport function pointDistance(points: PointTuple[], x: number, y: number) {\n  return distanceAtSegment(points, x, y);\n}\nexport function tangentAngle(points: PointTuple[], t: number) {\n  return angleAtSegments(points, t);\n}\n","import { box as polylineBox } from './polyline';\nimport {\n  angleAtSegments,\n  distanceAtSegment,\n  lengthOfSegment,\n  pointAtSegments,\n} from './segments';\nimport type { PointTuple } from './types';\n\nfunction getAllPoints(points: PointTuple[]) {\n  const tmp = points.slice(0);\n  if (points.length) {\n    tmp.push(points[0]);\n  }\n  return tmp;\n}\n\nexport function box(points: PointTuple[]) {\n  return polylineBox(points);\n}\nexport function length(points: PointTuple[]) {\n  return lengthOfSegment(getAllPoints(points));\n}\nexport function pointAt(points: PointTuple[], t: number) {\n  return pointAtSegments(getAllPoints(points), t);\n}\nexport function pointDistance(points: PointTuple[], x: number, y: number) {\n  return distanceAtSegment(getAllPoints(points), x, y);\n}\nexport function tangentAngle(points: PointTuple[], t: number) {\n  return angleAtSegments(getAllPoints(points), t);\n}\n","import { isNumberEqual } from '@antv/util';\nimport { nearestPoint as nearestPointBezier } from './bezier';\nimport { pointAt as linePointAt } from './line';\nimport type { Point } from './types';\nimport { distance, getBBoxByArray, piMod } from './util';\n\n// 差值公式\nfunction quadraticAt(p0: number, p1: number, p2: number, t: number) {\n  const onet = 1 - t;\n  return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;\n}\n\n// 求极值\nfunction extrema(p0: number, p1: number, p2: number) {\n  const a = p0 + p2 - 2 * p1;\n  if (isNumberEqual(a, 0)) {\n    return [0.5];\n  }\n  const rst = (p0 - p1) / a;\n  if (rst <= 1 && rst >= 0) {\n    return [rst];\n  }\n  return [];\n}\n\nfunction derivativeAt(p0: number, p1: number, p2: number, t: number) {\n  return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);\n}\n\n// 分割贝塞尔曲线\nfunction divideQuadratic(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  t: number,\n) {\n  // 划分点\n  const xt = quadraticAt(x1, x2, x3, t);\n  const yt = quadraticAt(y1, y2, y3, t);\n\n  // 分割的第一条曲线的控制点\n  const controlPoint1 = linePointAt(x1, y1, x2, y2, t);\n  // 分割的第二条曲线的控制点\n  const controlPoint2 = linePointAt(x2, y2, x3, y3, t);\n  return [\n    [x1, y1, controlPoint1.x, controlPoint1.y, xt, yt],\n    [xt, yt, controlPoint2.x, controlPoint2.y, x3, y3],\n  ];\n}\n\n// 使用迭代法取贝塞尔曲线的长度\nfunction quadraticLength(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  iterationCount: number,\n): number {\n  if (iterationCount === 0) {\n    return (\n      (distance(x1, y1, x2, y2) +\n        distance(x2, y2, x3, y3) +\n        distance(x1, y1, x3, y3)) /\n      2\n    );\n  }\n  const quadratics = divideQuadratic(x1, y1, x2, y2, x3, y3, 0.5);\n  const left = quadratics[0] as [\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n  ];\n  const right = quadratics[1] as [\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n  ];\n  left.push(iterationCount - 1);\n  right.push(iterationCount - 1);\n  return quadraticLength(...left) + quadraticLength(...right);\n}\n\nexport function box(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n) {\n  const xExtrema = extrema(x1, x2, x3)[0];\n  const yExtrema = extrema(y1, y2, y3)[0];\n  // 控制点不加入 box 的计算\n  const xArr = [x1, x3];\n  const yArr = [y1, y3];\n  if (xExtrema !== undefined) {\n    xArr.push(quadraticAt(x1, x2, x3, xExtrema));\n  }\n  if (yExtrema !== undefined) {\n    yArr.push(quadraticAt(y1, y2, y3, yExtrema));\n  }\n  return getBBoxByArray(xArr, yArr);\n}\n\nexport function length(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n) {\n  return quadraticLength(x1, y1, x2, y2, x3, y3, 3);\n}\n\nexport function nearestPoint(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x0: number,\n  y0: number,\n) {\n  return nearestPointBezier([x1, x2, x3], [y1, y2, y3], x0, y0, quadraticAt);\n}\n\nexport function pointDistance(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x0: number,\n  y0: number,\n) {\n  const point = nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);\n  return distance(point.x, point.y, x0, y0);\n}\n\n// interpolationAt: quadraticAt,\nexport function pointAt(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  t: number,\n): Point {\n  return {\n    x: quadraticAt(x1, x2, x3, t),\n    y: quadraticAt(y1, y2, y3, t),\n  };\n}\n\nexport function divide(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  t: number,\n) {\n  return divideQuadratic(x1, y1, x2, y2, x3, y3, t);\n}\n\nexport function tangentAngle(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  t: number,\n) {\n  const dx = derivativeAt(x1, x2, x3, t);\n  const dy = derivativeAt(y1, y2, y3, t);\n  const angle = Math.atan2(dy, dx);\n  return piMod(angle);\n}\n"],"names":["_arrayLikeToArray","r","a","length","e","n","Array","_unsupportedIterableToArray","arrayLikeToArray","t","toString","call","slice","constructor","name","from","test","_slicedToArray","isArray","arrayWithHoles","l","Symbol","iterator","i","u","f","o","next","Object","done","push","value","iterableToArrayLimit","unsupportedIterableToArray","TypeError","nonIterableRest","_toConsumableArray","arrayWithoutHoles","iterableToArray","nonIterableSpread","distance","x1","y1","x2","y2","dx","dy","Math","sqrt","getBBoxByArray","xArr","yArr","minX","min","apply","minY","x","y","width","max","height","piMod","angle","PI","copysign","v1","v2","absv","abs","xAt","cx","cy","rx","ry","xRotation","cos","sin","yAt","getPoint","rotate","isNumberEqual","b","precision","out","ARRAY_TYPE","Float32Array","glMatrix.ARRAY_TYPE","nearestPoint","tCallback","d","Infinity","v0","segNum","increaseRate","interval","_t","concat","d1","count","prev","d2","pointAt","pointDistance","cross","pointToLine","vec2","len","cubicAt","p0","p1","p2","p3","onet","derivativeAt","extrema","t1","t2","discSqrt","c","extremas","disc","cubicLength","x3","y3","x4","y4","iterationCount","totalLength","snapLength","cubics","xt","yt","c1","linePointAt","c2","c3","c12","c23","divideCubic","left","right","x0","y0","bezierNearestPoint","analyzePoints","points","segments","to","lengthOfSegment","pointAtSegments","_analyzePoints","startRatio","point","seg","currentRatio","angleAtSegments","_analyzePoints2","atan2","distanceAtSegment","minDistance","nextPoint","box","getAllPoints","tmp","quadraticAt","rst","quadraticLength","quadratics","controlPoint1","controlPoint2","divideQuadratic","nearestPointBezier","startAngle","endAngle","xDim","atan","tan","xExtrema","maxX","xs","xAngle","yDim","yExtrema","maxY","ys","yAngle","_relativeVector","relativePoint","relativeX","relativeY","px","py","squareA","squareB","nearestX","nearestY","ex","pow","ey","rx1","ry1","qx","qy","hypot","q","asin","ellipseNearestPoint","getAngle","vector","derivativeXAt","derivativeYAt","polylineBox","undefined"],"mappings":";;;;;;;;2PAAA,SAASA,EAAkBC,EAAGC,IAC3B,MAAQA,GAAKA,EAAID,EAAEE,UAAYD,EAAID,EAAEE,QACtC,IAAK,IAAIC,EAAI,EAAGC,EAAIC,MAAMJ,GAAQA,EAAJE,EAAOA,IAAKC,EAAED,GAAKH,EAAEG,GACnD,OAAOC,CACT,CCHA,SAASE,EAA4BN,EAAGC,GACtC,GAAID,EAAG,CACL,GAAI,iBAAmBA,EAAG,OAAOO,EAAiBP,EAAGC,GACrD,IAAIO,EAAI,GAAGC,SAASC,KAAKV,GAAGW,MAAM,GAAI,GACtC,MAAO,WAAaH,GAAKR,EAAEY,cAAgBJ,EAAIR,EAAEY,YAAYC,MAAO,QAAUL,GAAK,QAAUA,EAAIH,MAAMS,KAAKd,GAAK,cAAgBQ,GAAK,2CAA2CO,KAAKP,GAAKD,EAAiBP,EAAGC,QAAK,CACrN,CACH,CCHA,SAASe,EAAehB,EAAGG,GACzB,OCLF,SAAyBH,GACvB,GAAIK,MAAMY,QAAQjB,GAAI,OAAOA,CAC/B,CDGSkB,CAAelB,IELxB,SAA+BA,EAAGmB,GAChC,IAAIX,EAAI,MAAQR,EAAI,KAAO,oBAAsBoB,QAAUpB,EAAEoB,OAAOC,WAAarB,EAAE,cACnF,GAAI,MAAQQ,EAAG,CACb,IAAIL,EACFC,EACAkB,EACAC,EACAtB,EAAI,GACJuB,GAAI,EACJC,GAAI,EACN,IACE,GAAIH,GAAKd,EAAIA,EAAEE,KAAKV,IAAI0B,KAAM,IAAMP,EAAG,CACrC,GAAIQ,OAAOnB,KAAOA,EAAG,OACrBgB,GAAI,CACZ,MAAa,OAASA,GAAKrB,EAAImB,EAAEZ,KAAKF,IAAIoB,QAAU3B,EAAE4B,KAAK1B,EAAE2B,OAAQ7B,EAAEC,SAAWiB,GAAIK,GAAI,GACrF,CAAC,MAAOxB,GACPyB,GAAI,EAAIrB,EAAIJ,CAClB,CAAc,QACR,IACE,IAAKwB,GAAK,MAAQhB,EAAU,SAAMe,EAAIf,EAAU,SAAKmB,OAAOJ,KAAOA,GAAI,MAC/E,CAAgB,QACR,GAAIE,EAAG,MAAMrB,CACd,CACF,CACD,OAAOH,CACR,CACH,CFrB8B8B,CAAqB/B,EAAGG,IAAM6B,EAA2BhC,EAAGG,IGL1F,WACE,MAAM,IAAI8B,UAAU,4IACtB,CHGgGC,EAChG,CIFA,SAASC,EAAmBnC,GAC1B,OCJF,SAA4BA,GAC1B,GAAIK,MAAMY,QAAQjB,GAAI,OAAOO,EAAiBP,EAChD,CDESoC,CAAkBpC,IEL3B,SAA0BA,GACxB,GAAI,oBAAsBoB,QAAU,MAAQpB,EAAEoB,OAAOC,WAAa,MAAQrB,EAAE,cAAe,OAAOK,MAAMS,KAAKd,EAC/G,CFGiCqC,CAAgBrC,IAAMgC,EAA2BhC,IGLlF,WACE,MAAM,IAAIiC,UAAU,uIACtB,CHGwFK,EACxF,CIJO,SAASC,EAASC,EAAYC,EAAYC,EAAYC,GAC3D,IAAMC,EAAKJ,EAAKE,EACVG,EAAKJ,EAAKE,EAChB,OAAOG,KAAKC,KAAKH,EAAKA,EAAKC,EAAKA,EAClC,CAEO,SAASG,EAAeC,EAAgBC,GAC7C,IAAMC,EAAOL,KAAKM,IAAGC,MAARP,KAAIX,EAAQc,IACnBK,EAAOR,KAAKM,IAAGC,MAARP,KAAIX,EAAQe,IAGzB,MAAO,CACLK,EAAGJ,EACHK,EAAGF,EACHG,MALWX,KAAKY,IAAGL,MAARP,KAAIX,EAAQc,IAKTE,EACdQ,OALWb,KAAKY,IAAGL,MAARP,KAAIX,EAAQe,IAKRI,EAEnB,CAWO,SAASM,EAAMC,GACpB,OAAQA,EAAkB,EAAVf,KAAKgB,KAAqB,EAAVhB,KAAKgB,GACvC,CC7BA,SAASC,EAASC,EAAYC,GAC5B,IAAMC,EAAOpB,KAAKqB,IAAIH,GACtB,OAAOC,EAAK,EAAIC,GAAe,EAARA,CACzB,CC2CA,SAASE,EACPC,EACAC,EACAC,EACAC,EACAC,EACAZ,GAEA,OACEU,EAAKzB,KAAK4B,IAAID,GAAa3B,KAAK4B,IAAIb,GACpCW,EAAK1B,KAAK6B,IAAIF,GAAa3B,KAAK6B,IAAId,GACpCQ,CAEJ,CAGA,SAASO,EACPP,EACAC,EACAC,EACAC,EACAC,EACAZ,GAEA,OACEU,EAAKzB,KAAK6B,IAAIF,GAAa3B,KAAK4B,IAAIb,GACpCW,EAAK1B,KAAK4B,IAAID,GAAa3B,KAAK6B,IAAId,GACpCS,CAEJ,CAUA,SAASO,EAASN,EAAYC,EAAYX,GACxC,MAAO,CACLN,EAAGgB,EAAKzB,KAAK4B,IAAIb,GACjBL,EAAGgB,EAAK1B,KAAK6B,IAAId,GAErB,CAGA,SAASiB,EAAOvB,EAAWC,EAAWK,GACpC,IAAMa,EAAM5B,KAAK4B,IAAIb,GACfc,EAAM7B,KAAK6B,IAAId,GACrB,MAAO,CAACN,EAAImB,EAAMlB,EAAImB,EAAKpB,EAAIoB,EAAMnB,EAAIkB,EAC3C,CC/Fe,SAASK,EAAc9E,EAAG+E,EAAGC,GAExC,YADkB,IAAdA,IAAwBA,EANhB,MAOLhF,IAAM+E,GAAuBC,EAAlBnC,KAAKqB,IAAIlE,EAAI+E,EACnC,CCDO,ICMDE,EDNKC,EAAqC,oBAAjBC,aAA+BA,aAAe/E,MCMvE6E,EAAM,IAAIG,EAAoB,GAC9BA,GAAuBD,eACzBF,EAAI,GAAK,EACTA,EAAI,GAAK,GCJN,SAASI,EACdrC,EACAC,EACAK,EACAC,EACA+B,EACArF,GAEA,IAAIM,GAAK,EACLgF,EAAIC,IACFC,EAAiB,CAACnC,EAAGC,GAEvBmC,EAAS,GACTzF,GAAUA,EAAS,MACrByF,EAASzF,EAAS,IAMpB,IAJA,IAAM0F,EAAe,EAAID,EAErBE,EAAWD,EAAe,GAErBtE,EAAI,EAAQqE,GAALrE,EAAaA,IAAK,CAChC,IAAMwE,EAAKxE,EAAIsE,EACT5B,EAAiB,CACrBuB,EAASlC,WAAA,EAAAlB,EAAIc,EAAK8C,OAAO,CAACD,MAC1BP,EAASlC,WAAA,EAAAlB,EAAIe,EAAK6C,OAAO,CAACD,OAGtBE,EAAKzD,EAASmD,EAAG,GAAIA,EAAG,GAAI1B,EAAG,GAAIA,EAAG,IACnCwB,EAALQ,IACFxF,EAAIsF,EACJN,EAAIQ,EAER,CAEA,GAAU,IAANxF,EACF,MAAO,CACL+C,EAAGN,EAAK,GACRO,EAAGN,EAAK,IAGZ,GAAU,IAAN1C,EAAS,CACX,IAAMyF,EAAQhD,EAAK/C,OACnB,MAAO,CACLqD,EAAGN,EAAKgD,EAAQ,GAChBzC,EAAGN,EAAK+C,EAAQ,GAEpB,CACAT,EAAIC,IAEJ,IAAK,IAAInE,EAAI,EAAO,GAAJA,GA1DF,MA2DRuE,EADkBvE,IAAK,CAK3B,IAAM4E,EAAO1F,EAAIqF,EACXnE,EAAOlB,EAAIqF,EAEX7B,EAAK,CACTuB,EAASlC,WAAA,EAAAlB,EAAIc,EAAK8C,OAAO,CAACG,MAC1BX,EAASlC,WAAA,EAAAlB,EAAIe,EAAK6C,OAAO,CAACG,OAGtBF,EAAKzD,EAASmD,EAAG,GAAIA,EAAG,GAAI1B,EAAG,GAAIA,EAAG,IAC5C,GAAIkC,GAAQ,GAAUV,EAALQ,EACfxF,EAAI0F,EACJV,EAAIQ,MACC,CACL,IAAM/B,EAAK,CACTsB,EAASlC,WAAA,EAAAlB,EAAIc,EAAK8C,OAAO,CAACrE,MAC1B6D,EAASlC,WAAA,EAAAlB,EAAIe,EAAK6C,OAAO,CAACrE,OAEtByE,EAAK5D,EAASmD,EAAG,GAAIA,EAAG,GAAIzB,EAAG,GAAIA,EAAG,IAChC,GAARvC,GAAkB8D,EAALW,GACf3F,EAAIkB,EACJ8D,EAAIW,GAEJN,GAAY,EAEhB,CACF,CAEA,MAAO,CACLtC,EAAGgC,EAASlC,aAAAlB,EAAIc,EAAK8C,OAAO,CAACvF,MAC7BgD,EAAG+B,EAASlC,aAAAlB,EAAIe,EAAK6C,OAAO,CAACvF,MAEjC,CCrFO,SAAS4F,EACd5D,EACAC,EACAC,EACAC,EACAnC,GAEA,MAAO,CACL+C,GAAI,EAAI/C,GAAKgC,EAAKhC,EAAIkC,EACtBc,GAAI,EAAIhD,GAAKiC,EAAKjC,EAAImC,EAE1B,CAEO,SAAS0D,EACd7D,EACAC,EACAC,EACAC,EACAY,EACAC,GAIA,IAAM8C,GAAS5D,EAAKF,IAAOe,EAAIf,IAAOG,EAAKF,IAAOe,EAAIf,GACtD,OAAY,EAAR6D,EACK/D,EAASC,EAAIC,EAAIc,EAAGC,GAGzB8C,GADkB5D,EAAKF,IAAOE,EAAKF,IAAOG,EAAKF,IAAOE,EAAKF,GAEtDF,EAASG,EAAIC,EAAIY,EAAGC,GAEtB+C,EAAY/D,EAAIC,EAAIC,EAAIC,EAAIY,EAAGC,EACxC,CAEO,SAAS+C,EACd/D,EACAC,EACAC,EACAC,EACAY,EACAC,GAEA,IAAMgC,EAAsB,CAAC9C,EAAKF,EAAIG,EAAKF,GAE3C,GFwdK,SAAqBxC,EAAG+E,GAC7B,OAAO/E,EAAE,KAAO+E,EAAE,IAAM/E,EAAE,KAAO+E,EAAE,EACrC,CE1dMwB,CAAiBhB,EAAG,CAAC,EAAG,IAC1B,OAAO1C,KAAKC,MAAMQ,EAAIf,IAAOe,EAAIf,IAAOgB,EAAIf,IAAOe,EAAIf,IAEzD,IAAMlB,EAAsB,EAAEiE,EAAE,GAAIA,EAAE,IAGtC,OFwPK,SAAmBN,EAAKjF,GAC7B,IAAIsD,EAAItD,EAAE,GACRuD,EAAIvD,EAAE,GACJwG,EAAMlD,EAAIA,EAAIC,EAAIA,EAClBiD,EAAM,IAERA,EAAM,EAAI3D,KAAKC,KAAK0D,IAEtBvB,EAAI,GAAKjF,EAAE,GAAKwG,EAChBvB,EAAI,GAAKjF,EAAE,GAAKwG,CAElB,CErQED,CAAejF,EAAGA,GAEXuB,KAAKqB,IF4QP,SAAalE,EAAG+E,GACrB,OAAO/E,EAAE,GAAK+E,EAAE,GAAK/E,EAAE,GAAK+E,EAAE,EAChC,CE9QkBwB,CADY,CAACjD,EAAIf,EAAIgB,EAAIf,GACblB,GAC9B,CCzDA,SAASmF,EAAQC,EAAYC,EAAYC,EAAYC,EAAYtG,GAC/D,IAAMuG,EAAO,EAAIvG,EACjB,OACEuG,EAAOA,EAAOA,EAAOJ,EACrB,EAAIC,EAAKpG,EAAIuG,EAAOA,EACpB,EAAIF,EAAKrG,EAAIA,EAAIuG,EACjBD,EAAKtG,EAAIA,EAAIA,CAEjB,CAEA,SAASwG,EACPL,EACAC,EACAC,EACAC,EACAtG,GAEA,IAAMuG,EAAO,EAAIvG,EACjB,OACE,GAAKuG,EAAOA,GAAQH,EAAKD,GAAM,EAAII,EAAOvG,GAAKqG,EAAKD,GAAMpG,EAAIA,GAAKsG,EAAKD,GAE5E,CAEA,SAASI,EAAQN,EAAYC,EAAYC,EAAYC,GACnD,IAIII,EACAC,EACAC,EANEnH,GAAK,EAAI0G,EAAK,EAAIC,EAAK,EAAIC,EAAK,EAAIC,EACpC9B,EAAI,EAAI2B,EAAK,GAAKC,EAAK,EAAIC,EAC3BQ,EAAI,EAAIT,EAAK,EAAID,EACjBW,EAAW,GAKjB,GAAIvC,EAAc9E,EAAG,GACd8E,EAAcC,EAAG,IAEV,GADVkC,GAAMG,EAAIrC,IACKkC,EAAM,GACnBI,EAASzF,KAAKqF,OAGb,CACL,IAAMK,EAAOvC,EAAIA,EAAI,EAAI/E,EAAIoH,EACzBtC,EAAcwC,EAAM,GACtBD,EAASzF,MAAMmD,GAAK,EAAI/E,IACfsH,EAAO,IAGhBJ,IAAOnC,GAFPoC,EAAWtE,KAAKC,KAAKwE,MAEG,EAAItH,GAClB,GAFViH,IAAOlC,EAAIoC,IAAa,EAAInH,KAEbiH,EAAM,GACnBI,EAASzF,KAAKqF,GAEN,EAANC,GAAWA,EAAM,GACnBG,EAASzF,KAAKsF,GAGpB,CACA,OAAOG,CACT,CA8BA,SAASE,EACPhF,EACAC,EACAC,EACAC,EACA8E,EACAC,EACAC,EACAC,EACAC,GAEA,GAAuB,IAAnBA,EACF,OFJG,SAAoB5E,EAAgBC,GAGzC,IAFA,IAAI4E,EAAc,EACZ7B,EAAQhD,EAAK/C,OACVoB,EAAI,EAAO2E,EAAJ3E,EAAWA,IAKzBwG,GAAevF,EAJLU,EAAK3B,GACL4B,EAAK5B,GACD2B,GAAM3B,EAAI,GAAK2E,GACf/C,GAAM5B,EAAI,GAAK2E,IAG/B,OAAO6B,EAAc,CACvB,CEPWC,CAAW,CAACvF,EAAIE,EAAI+E,EAAIE,GAAK,CAAClF,EAAIE,EAAI+E,EAAIE,IAEnD,IAAMI,EAzCR,SACExF,EACAC,EACAC,EACAC,EACA8E,EACAC,EACAC,EACAC,EACApH,GAGA,IAAMyH,EAAKvB,EAAQlE,EAAIE,EAAI+E,EAAIE,EAAInH,GAC7B0H,EAAKxB,EAAQjE,EAAIE,EAAI+E,EAAIE,EAAIpH,GAE7B2H,EAAKC,EAAY5F,EAAIC,EAAIC,EAAIC,EAAInC,GACjC6H,EAAKD,EAAY1F,EAAIC,EAAI8E,EAAIC,EAAIlH,GACjC8H,EAAKF,EAAYX,EAAIC,EAAIC,EAAIC,EAAIpH,GACjC+H,EAAMH,EAAYD,EAAG5E,EAAG4E,EAAG3E,EAAG6E,EAAG9E,EAAG8E,EAAG7E,EAAGhD,GAC1CgI,EAAMJ,EAAYC,EAAG9E,EAAG8E,EAAG7E,EAAG8E,EAAG/E,EAAG+E,EAAG9E,EAAGhD,GAChD,MAAO,CACL,CAACgC,EAAIC,EAAI0F,EAAG5E,EAAG4E,EAAG3E,EAAG+E,EAAIhF,EAAGgF,EAAI/E,EAAGyE,EAAIC,GACvC,CAACD,EAAIC,EAAIM,EAAIjF,EAAGiF,EAAIhF,EAAG8E,EAAG/E,EAAG+E,EAAG9E,EAAGmE,EAAIC,GAE3C,CAiBiBa,CAAYjG,EAAIC,EAAIC,EAAIC,EAAI8E,EAAIC,EAAIC,EAAIC,EAAI,IACrDc,EAUL,GAAA3C,OAAA5D,EAAO6F,EAAO,IAAE,CAAEH,EAAiB,IAC9Bc,EAUL,GAAA5C,OAAA5D,EAAO6F,EAAO,IAAE,CAAEH,EAAiB,IACpC,OAAOL,EAAWnE,WAAAlB,EAAAA,EAAIuG,IAAQlB,EAAWnE,WAAA,EAAAlB,EAAIwG,GAC/C,CAuCO,SAASrD,EACd9C,EACAC,EACAC,EACAC,EACA8E,EACAC,EACAC,EACAC,EACAgB,EACAC,EACA3I,GAEA,OAAO4I,EACL,CAACtG,EAAIE,EAAI+E,EAAIE,GACb,CAAClF,EAAIE,EAAI+E,EAAIE,GACbgB,EACAC,EACAnC,EACAxG,EAEJ,CC1LA,SAAS6I,EAAcC,GAIrB,IAFA,IAAIlB,EAAc,EACZmB,EAAsB,GACnB3H,EAAI,EAAO0H,EAAO9I,OAAS,EAApBoB,EAAuBA,IAAK,CAC1C,IAAMR,EAAOkI,EAAO1H,GACd4H,EAAKF,EAAO1H,EAAI,GAChBpB,EAASqC,EAASzB,EAAK,GAAIA,EAAK,GAAIoI,EAAG,GAAIA,EAAG,IAMpDD,EAASpH,KALG,CACVf,KAAAA,EACAoI,GAAAA,EACAhJ,OAAAA,IAGF4H,GAAe5H,CACjB,CACA,MAAO,CAAE+I,SAAAA,EAAUnB,YAAAA,EACrB,CAEO,SAASqB,EAAgBH,GAC9B,GAAoB,EAAhBA,EAAO9I,OACT,OAAO,EAGT,IADA,IAAI4H,EAAc,EACTxG,EAAI,EAAO0H,EAAO9I,OAAS,EAApBoB,EAAuBA,IAAK,CAC1C,IAAMR,EAAOkI,EAAO1H,GACd4H,EAAKF,EAAO1H,EAAI,GACtBwG,GAAevF,EAASzB,EAAK,GAAIA,EAAK,GAAIoI,EAAG,GAAIA,EAAG,GACtD,CACA,OAAOpB,CACT,CAQO,SAASsB,EAAgBJ,EAAsBxI,GAEpD,GAAIA,EAAI,GAAS,EAAJA,GAAyB,EAAhBwI,EAAO9I,OAC3B,OAAO,KAET,IAAAmJ,EAAkCN,EAAcC,GAAxCC,EAAQI,EAARJ,SAAUnB,EAAWuB,EAAXvB,YAElB,GAAoB,IAAhBA,EACF,MAAO,CACLvE,EAAGyF,EAAO,GAAG,GACbxF,EAAGwF,EAAO,GAAG,IAMjB,IAFA,IAAIM,EAAa,EACbC,EAAQ,KACHjI,EAAI,EAAO2H,EAAS/I,OAAboB,EAAqBA,IAAK,CACxC,IAAMkI,EAAMP,EAAS3H,GACbR,EAAa0I,EAAb1I,KAAMoI,EAAOM,EAAPN,GACRO,EAAeD,EAAItJ,OAAS4H,EAClC,GAAItH,GAAK8I,GAAmBA,EAAaG,GAAlBjJ,EAAgC,CAErD+I,EAAQnD,EAAQtF,EAAK,GAAIA,EAAK,GAAIoI,EAAG,GAAIA,EAAG,IADxB1I,EAAI8I,GAAcG,GAEtC,KACF,CACAH,GAAcG,CAChB,CACA,OAAOF,CACT,CAOO,SAASG,EAAgBV,EAAsBxI,GAEpD,GAAIA,EAAI,GAAS,EAAJA,GAAyB,EAAhBwI,EAAO9I,OAC3B,OAAO,EAMT,IAJA,IAAAyJ,EAAkCZ,EAAcC,GAAxCC,EAAQU,EAARV,SAAUnB,EAAW6B,EAAX7B,YAEdwB,EAAa,EACbzF,EAAQ,EACHvC,EAAI,EAAO2H,EAAS/I,OAAboB,EAAqBA,IAAK,CACxC,IAAMkI,EAAMP,EAAS3H,GACbR,EAAa0I,EAAb1I,KAAMoI,EAAOM,EAAPN,GACRO,EAAeD,EAAItJ,OAAS4H,EAClC,GAAItH,GAAK8I,GAAmBA,EAAaG,GAAlBjJ,EAAgC,CACrDqD,EAAQf,KAAK8G,MAAMV,EAAG,GAAKpI,EAAK,GAAIoI,EAAG,GAAKpI,EAAK,IACjD,KACF,CACAwI,GAAcG,CAChB,CACA,OAAO5F,CACT,CAEO,SAASgG,EAAkBb,EAAsBzF,EAAWC,GAEjE,IADA,IAAIsG,EAAcrE,IACTnE,EAAI,EAAO0H,EAAO9I,OAAS,EAApBoB,EAAuBA,IAAK,CAC1C,IAAMiI,EAAQP,EAAO1H,GACfyI,EAAYf,EAAO1H,EAAI,GACvBiB,EAAW8D,EACfkD,EAAM,GACNA,EAAM,GACNQ,EAAU,GACVA,EAAU,GACVxG,EACAC,GAEasG,EAAXvH,IACFuH,EAAcvH,EAElB,CACA,OAAOuH,CACT,CC5GO,SAASE,EAAIhB,GAGlB,IAFA,IAAM/F,EAAO,GACPC,EAAO,GACJ5B,EAAI,EAAO0H,EAAO9I,OAAXoB,EAAmBA,IAAK,CACtC,IAAMiI,EAAQP,EAAO1H,GACrB2B,EAAKpB,KAAK0H,EAAM,IAChBrG,EAAKrB,KAAK0H,EAAM,GAClB,CACA,OAAOvG,EAAeC,EAAMC,EAC9B,CCTA,SAAS+G,EAAajB,GACpB,IAAMkB,EAAMlB,EAAOrI,MAAM,GAIzB,OAHIqI,EAAO9I,QACTgK,EAAIrI,KAAKmH,EAAO,IAEXkB,CACT,CCRA,SAASC,EAAYxD,EAAYC,EAAYC,EAAYrG,GACvD,IAAMuG,EAAO,EAAIvG,EACjB,OAAOuG,EAAOA,EAAOJ,EAAK,EAAInG,EAAIuG,EAAOH,EAAKpG,EAAIA,EAAIqG,CACxD,CAGA,SAASI,EAAQN,EAAYC,EAAYC,GACvC,IAAM5G,EAAI0G,EAAKE,EAAK,EAAID,EACxB,GAAI7B,EAAc9E,EAAG,GACnB,MAAO,CAAC,IAEV,IAAMmK,GAAOzD,EAAKC,GAAM3G,EACxB,OAAImK,EAAO,GAAY,EAAPA,EAGT,GAFE,CAACA,EAGZ,CA+BA,SAASC,EACP7H,EACAC,EACAC,EACAC,EACA8E,EACAC,EACAG,GAEA,GAAuB,IAAnBA,EACF,OACGtF,EAASC,EAAIC,EAAIC,EAAIC,GACpBJ,EAASG,EAAIC,EAAI8E,EAAIC,GACrBnF,EAASC,EAAIC,EAAIgF,EAAIC,IACvB,EAGJ,IAAM4C,EAzCR,SACE9H,EACAC,EACAC,EACAC,EACA8E,EACAC,EACAlH,GAGA,IAAMyH,EAAKkC,EAAY3H,EAAIE,EAAI+E,EAAIjH,GAC7B0H,EAAKiC,EAAY1H,EAAIE,EAAI+E,EAAIlH,GAG7B+J,EAAgBnC,EAAY5F,EAAIC,EAAIC,EAAIC,EAAInC,GAE5CgK,EAAgBpC,EAAY1F,EAAIC,EAAI8E,EAAIC,EAAIlH,GAClD,MAAO,CACL,CAACgC,EAAIC,EAAI8H,EAAchH,EAAGgH,EAAc/G,EAAGyE,EAAIC,GAC/C,CAACD,EAAIC,EAAIsC,EAAcjH,EAAGiH,EAAchH,EAAGiE,EAAIC,GAEnD,CAoBqB+C,CAAgBjI,EAAIC,EAAIC,EAAIC,EAAI8E,EAAIC,EAAI,IACrDgB,EAAO4B,EAAW,GASlB3B,EAAQ2B,EAAW,GAWzB,OAFA5B,EAAK7G,KAAKgG,EAAiB,GAC3Bc,EAAM9G,KAAKgG,EAAiB,GACrBwC,EAAehH,WAAAlB,EAAAA,EAAIuG,IAAQ2B,EAAehH,WAAA,EAAAlB,EAAIwG,GACvD,CAmCO,SAASrD,EACd9C,EACAC,EACAC,EACAC,EACA8E,EACAC,EACAkB,EACAC,GAEA,OAAO6B,EAAmB,CAAClI,EAAIE,EAAI+E,GAAK,CAAChF,EAAIE,EAAI+E,GAAKkB,EAAIC,EAAIsB,EAChE,UVrCO,SACL9F,EACAC,EACAC,EACAC,EACAC,EACAkG,EACAC,GAMA,IAJA,IAAMC,EAxER,SAAkBtG,EAAYC,EAAYC,GACxC,OAAO3B,KAAKgI,MAAOtG,EAAKD,EAAMzB,KAAKiI,IAAItG,GACzC,CAsEeuG,CAASzG,EAAIC,EAAIC,GAC1BtB,EAAOsC,IACPwF,GAAQxF,IACNyF,EAAK,CAACP,EAAYC,GACftJ,EAAe,GAAVwB,KAAKgB,GAAuB,EAAVhB,KAAKgB,IAAVxC,EAAkBA,GAAKwB,KAAKgB,GAAI,CACzD,IAAMqH,EAASN,EAAOvJ,EACLsJ,EAAbD,EACeQ,EAAbR,GAAgCC,EAATO,GACzBD,EAAGrJ,KAAKsJ,GAEUA,EAAXP,GAA8BD,EAATQ,GAC9BD,EAAGrJ,KAAKsJ,EAEZ,CAEA,IAAK,IAAI7J,EAAI,EAAO4J,EAAGhL,OAAPoB,EAAeA,IAAK,CAClC,IAAMiC,EAAIa,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAWyG,EAAG5J,IACpC6B,EAAJI,IACFJ,EAAOI,GAELA,EAAI0H,IACNA,EAAO1H,EAEX,CAMA,IAJA,IAAM6H,EA5FR,SAAkB7G,EAAYC,EAAYC,GACxC,OAAO3B,KAAKgI,KAAKtG,GAAMD,EAAKzB,KAAKiI,IAAItG,IACvC,CA0Fe4G,CAAS9G,EAAIC,EAAIC,GAC1BnB,EAAOmC,IACP6F,GAAQ7F,IACN8F,EAAK,CAACZ,EAAYC,GACftJ,EAAe,GAAVwB,KAAKgB,GAAuB,EAAVhB,KAAKgB,IAAVxC,EAAkBA,GAAKwB,KAAKgB,GAAI,CACzD,IAAM0H,EAASJ,EAAO9J,EACLsJ,EAAbD,EACea,EAAbb,GAAgCC,EAATY,GACzBD,EAAG1J,KAAK2J,GAEUA,EAAXZ,GAA8BD,EAATa,GAC9BD,EAAG1J,KAAK2J,EAEZ,CAEA,IAAK,IAAIlK,EAAI,EAAOiK,EAAGrL,OAAPoB,EAAeA,IAAK,CAClC,IAAMkC,EAAIoB,EAAIP,EAAIC,EAAIC,EAAIC,EAAIC,EAAW8G,EAAGjK,IACpCgC,EAAJE,IACFF,EAAOE,GAELA,EAAI8H,IACNA,EAAO9H,EAEX,CAEA,MAAO,CACLD,EAAGJ,EACHK,EAAGF,EACHG,MAAOwH,EAAO9H,EACdQ,OAAQ2H,EAAOhI,EAEnB,oBAEO,SACLe,EACAC,EACAC,EACAC,EACAC,EACAkG,EACAC,EACAhC,EACAC,GAGA,IACA4C,EAAAzK,EADuB8D,EAAO8D,EAAKvE,EAAIwE,EAAKvE,GAAKG,GAClB,GAE3BiH,EDrKC,SACLnI,EACAC,EACAe,EACAC,EACAoE,EACAC,GAEA,IAAM5I,EAAIsE,EACJS,EAAIR,EAEV,GAAU,IAANvE,GAAiB,IAAN+E,EACb,MAAO,CACLzB,EAAAA,EACAC,EAAAA,GAeJ,IAXA,IAAMmI,EAAY/C,EAAKrF,EACjBqI,EAAY/C,EAAKrF,EACjBqI,EAAK/I,KAAKqB,IAAIwH,GACdG,EAAKhJ,KAAKqB,IAAIyH,GACdG,EAAU9L,EAAIA,EACd+L,EAAUhH,EAAIA,EAEhBxE,EAAIsC,KAAKgB,GAAK,EACdmI,EAAW,EACXC,EAAW,EAEN5K,EAAI,EAAO,EAAJA,EAAOA,IAAK,CAC1B2K,EAAWhM,EAAI6C,KAAK4B,IAAIlE,GACxB0L,EAAWlH,EAAIlC,KAAK6B,IAAInE,GAExB,IAAM2L,GAAOJ,EAAUC,GAAOlJ,KAAAsJ,IAAItJ,KAAK4B,IAAIlE,GAAM,GAAKP,EAChDoM,GAAOL,EAAUD,GAAOjJ,KAAAsJ,IAAItJ,KAAK6B,IAAInE,GAAM,GAAKwE,EAChDsH,EAAML,EAAWE,EACjBI,EAAML,EAAWG,EAEjBG,EAAKX,EAAKM,EACVM,EAAKX,EAAKO,EACVrM,EAAI8C,KAAK4J,MAAMH,EAAKD,GACpBK,EAAI7J,KAAK4J,MAAMD,EAAID,GAQzBhM,EAAIsC,KAAKM,IAAIN,KAAKgB,GAAK,EAAGhB,KAAKY,IAAI,EADnClD,GALgBR,EAAI8C,KAAK8J,MAAMN,EAAMG,EAAKF,EAAMC,IAAOxM,EAAI2M,IAGzD7J,KAAKC,KAAKgJ,EAAUC,EAAUC,EAAWA,EAAWC,EAAWA,IAInE,CAEA,MAAO,CACL3I,EAAGA,EAAIQ,EAASkI,EAAUN,GAC1BnI,EAAGA,EAAIO,EAASmI,EAAUN,GAE9B,CC6GsBiB,CAAoB,EAAG,EAAGtI,EAAIC,EAFzCiH,EAAA,GAAIA,EAAA,IAIP5H,EAzGR,SAAkBU,EAAYC,EAAYoE,EAAYC,GAGpD,OAFc/F,KAAK8G,MAAMf,EAAKtE,EAAIqE,EAAKpE,GAEb,EAAV1B,KAAKgB,KAAqB,EAAVhB,KAAKgB,GACvC,CAqGgBgJ,CAASvI,EAAIC,EAAIkH,EAAcnI,EAAGmI,EAAclI,GAElDmH,EAAR9G,EAEF6H,EAAgB7G,EAASN,EAAIC,EAAImG,GACxB9G,EAAQ+G,IAEjBc,EAAgB7G,EAASN,EAAIC,EAAIoG,IAGnC,IAAMmC,EAASjI,EAAO4G,EAAcnI,EAAGmI,EAAclI,EAAGiB,GACxD,MAAO,CACLlB,EAAGwJ,EAAO,GAAK1I,EACfb,EAAGuJ,EAAO,GAAKzI,EAEnB,oBA4CO,SACLD,EACAC,EACAC,EACAC,EACAC,EACAkG,EACAC,EACApK,GAEA,IAAMqD,GAAS+G,EAAWD,GAAcnK,EAAImK,EACtC/H,EA3PR,SACEyB,EACAC,EACAC,EACAC,EACAC,EACAkG,EACAC,EACA/G,GAEA,OACG,EAAIU,EAAKzB,KAAK4B,IAAID,GAAa3B,KAAK6B,IAAId,GACzCW,EAAK1B,KAAK6B,IAAIF,GAAa3B,KAAK4B,IAAIb,EAExC,CA6OamJ,CACT3I,EACAC,EACAC,EACAC,EACAC,EACAkG,EACAC,EACA/G,GAEIhB,EApPR,SACEwB,EACAC,EACAC,EACAC,EACAC,EACAkG,EACAC,EACA/G,GAEA,OACG,EAAIU,EAAKzB,KAAK6B,IAAIF,GAAa3B,KAAK6B,IAAId,GACzCW,EAAK1B,KAAK4B,IAAID,GAAa3B,KAAK4B,IAAIb,EAExC,CAsOaoJ,CACT5I,EACAC,EACAC,EACAC,EACAC,EACAkG,EACAC,EACA/G,GAEF,OAAOD,EAAMd,KAAK8G,MAAM/G,EAAID,GAC9B,aMjJO,SACLJ,EACAC,EACAC,EACAC,EACA8E,EACAC,EACAC,EACAC,GAMA,IAJA,IAAM3E,EAAO,CAACT,EAAImF,GACZzE,EAAO,CAACT,EAAImF,GACZoD,EAAW/D,EAAQzE,EAAIE,EAAI+E,EAAIE,GAC/B0D,EAAWpE,EAAQxE,EAAIE,EAAI+E,EAAIE,GAC5BtG,EAAI,EAAO0J,EAAS9K,OAAboB,EAAqBA,IACnC2B,EAAKpB,KAAK6E,EAAQlE,EAAIE,EAAI+E,EAAIE,EAAIqD,EAAS1J,KAE7C,IAAK,IAAIA,EAAI,EAAO+J,EAASnL,OAAboB,EAAqBA,IACnC4B,EAAKrB,KAAK6E,EAAQjE,EAAIE,EAAI+E,EAAIE,EAAIyD,EAAS/J,KAE7C,OAAO0B,EAAeC,EAAMC,EAC9B,gBAEO,SACLV,EACAC,EACAC,EACAC,EACA8E,EACAC,EACAC,EACAC,GAGA,OAAOJ,EAAYhF,EAAIC,EAAIC,EAAIC,EAAI8E,EAAIC,EAAIC,EAAIC,EAAI,EACrD,uCA0CO,SACLpF,EACAC,EACAC,EACAC,EACA8E,EACAC,EACAC,EACAC,EACApH,GAEA,MAAO,CACL+C,EAAGmD,EAAQlE,EAAIE,EAAI+E,EAAIE,EAAInH,GAC3BgD,EAAGkD,EAAQjE,EAAIE,EAAI+E,EAAIE,EAAIpH,GAE/B,uBAhCO,SACLgC,EACAC,EACAC,EACAC,EACA8E,EACAC,EACAC,EACAC,EACAgB,EACAC,EACA3I,GAEA,IAAMqJ,EAAQjE,EAAa9C,EAAIC,EAAIC,EAAIC,EAAI8E,EAAIC,EAAIC,EAAIC,EAAIgB,EAAIC,EAAI3I,GACnE,OAAOqC,EAASgH,EAAMhG,EAAGgG,EAAM/F,EAAGoF,EAAIC,EACxC,sBAiCO,SACLrG,EACAC,EACAC,EACAC,EACA8E,EACAC,EACAC,EACAC,EACApH,GAEA,IAAMoC,EAAKoE,EAAaxE,EAAIE,EAAI+E,EAAIE,EAAInH,GAClCqC,EAAKmE,EAAavE,EAAIE,EAAI+E,EAAIE,EAAIpH,GACxC,OAAOoD,EAAMd,KAAK8G,MAAM/G,EAAID,GAC9B,yBD1PO,SAAaJ,EAAYC,EAAYC,EAAYC,GACtD,OAAOK,EAAe,CAACR,EAAIE,GAAK,CAACD,EAAIE,GACvC,eAEO,SAAgBH,EAAYC,EAAYC,EAAYC,GACzD,OAAOJ,EAASC,EAAIC,EAAIC,EAAIC,EAC9B,+EAuDO,SAAsBH,EAAYC,EAAYC,EAAYC,GAC/D,OAAOG,KAAK8G,MAAMjH,EAAKF,EAAIC,EAAKF,EAClC,eIlDO,SAAawG,GAClB,OAAOkE,EAAYlE,EACrB,kBACO,SAAgBA,GACrB,OAAOG,EAAgBc,EAAajB,GACtC,mBACO,SAAiBA,EAAsBxI,GAC5C,OAAO4I,EAAgBa,EAAajB,GAASxI,EAC/C,yBACO,SAAuBwI,EAAsBzF,EAAWC,GAC7D,OAAOqG,EAAkBI,EAAajB,GAASzF,EAAGC,EACpD,wBACO,SAAsBwF,EAAsBxI,GACjD,OAAOkJ,EAAgBO,EAAajB,GAASxI,EAC/C,mCDZO,SAAgBwI,GACrB,OAAOG,EAAgBH,EACzB,oBACO,SAAiBA,EAAsBxI,GAC5C,OAAO4I,EAAgBJ,EAAQxI,EACjC,0BACO,SAAuBwI,EAAsBzF,EAAWC,GAC7D,OAAOqG,EAAkBb,EAAQzF,EAAGC,EACtC,yBACO,SAAsBwF,EAAsBxI,GACjD,OAAOkJ,EAAgBV,EAAQxI,EACjC,YEiEO,SACLgC,EACAC,EACAC,EACAC,EACA8E,EACAC,GAEA,IAAMsD,EAAW/D,EAAQzE,EAAIE,EAAI+E,GAAI,GAC/B4D,EAAWpE,EAAQxE,EAAIE,EAAI+E,GAAI,GAE/BzE,EAAO,CAACT,EAAIiF,GACZvE,EAAO,CAACT,EAAIiF,GAOlB,YANiByF,IAAbnC,GACF/H,EAAKpB,KAAKsI,EAAY3H,EAAIE,EAAI+E,EAAIuD,SAEnBmC,IAAb9B,GACFnI,EAAKrB,KAAKsI,EAAY1H,EAAIE,EAAI+E,EAAI2D,IAE7BrI,EAAeC,EAAMC,EAC9B,eAEO,SACLV,EACAC,EACAC,EACAC,EACA8E,EACAC,GAEA,OAAO2C,EAAgB7H,EAAIC,EAAIC,EAAIC,EAAI8E,EAAIC,EAAI,EACjD,2CAeO,SACLlF,EACAC,EACAC,EACAC,EACA8E,EACAC,EACAkB,EACAC,GAEA,IAAMU,EAAQjE,EAAa9C,EAAIC,EAAIC,EAAIC,EAAI8E,EAAIC,EAAIkB,EAAIC,GACvD,OAAOtG,EAASgH,EAAMhG,EAAGgG,EAAM/F,EAAGoF,EAAIC,EACxC","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,13,14,15]}