{"version":3,"file":"hierarchy.umd.js","sources":["../src/util.ts","../src/layout/hierarchy.ts","../src/layout/base.ts","../src/layout/non-layered-tidy.ts","../src/layout/separate-root.ts","../src/layout/do-layout.ts","../src/compact-box.ts","../src/layout/dendrogram.ts","../src/dendrogram.ts","../src/layout/indented.ts","../src/indented.ts","../src/layout/mindmap.ts","../src/mindmap.ts","../src/index.ts"],"sourcesContent":["import type { HierarchyNode } from './types';\n\n/**\n * Get average height or height for node's position calculation, according to align.\n * @param preNode previous node\n * @param node current node, whose position is going to be calculated\n * @param align 'center' means nodes align at the center, other value means align at the left-top\n * @param heightField field name for height value on preNode and node\n * @return the height for calculation\n */\nexport function getHeight(\n  preNode: HierarchyNode,\n  node: HierarchyNode,\n  align?: 'center' | undefined,\n  heightField: keyof HierarchyNode = 'height',\n): number {\n  const preNodeHeight = preNode[heightField] as number;\n  const nodeHeight = node[heightField] as number;\n  return align === 'center' ? (preNodeHeight + nodeHeight) / 2 : preNode.height;\n}\n\nexport const assign = Object.assign;\n","import { assign } from '../util';\nimport type { HierarchyData, HierarchyNode, HierarchyOptions, BoundingBox } from '../types';\n\nconst PEM = 18;\nconst DEFAULT_HEIGHT = PEM * 2;\nconst DEFAULT_GAP = PEM;\n\nconst DEFAULT_OPTIONS: Required<\n  Pick<\n    HierarchyOptions,\n    | 'getId'\n    | 'getPreH'\n    | 'getPreV'\n    | 'getHGap'\n    | 'getVGap'\n    | 'getChildren'\n    | 'getHeight'\n    | 'getWidth'\n  >\n> = {\n  getId(d: HierarchyData): string {\n    return (d.id || d.name) as string;\n  },\n  getPreH(d: HierarchyData): number {\n    return d.preH || 0;\n  },\n  getPreV(d: HierarchyData): number {\n    return d.preV || 0;\n  },\n  getHGap(d: HierarchyData): number {\n    return d.hgap || DEFAULT_GAP;\n  },\n  getVGap(d: HierarchyData): number {\n    return d.vgap || DEFAULT_GAP;\n  },\n  getChildren(d: HierarchyData): HierarchyData[] | undefined {\n    return d.children;\n  },\n  getHeight(d: HierarchyData): number {\n    return d.height || DEFAULT_HEIGHT;\n  },\n  getWidth(d: HierarchyData): number {\n    const label = d.label || ' ';\n    return d.width || label.split('').length * PEM; // FIXME DO NOT get width like this\n  },\n};\n\nclass Node implements HierarchyNode {\n  data: HierarchyData;\n  id: string;\n  x: number = 0;\n  y: number = 0;\n  width: number;\n  height: number;\n  depth: number = 0;\n  children: HierarchyNode[] = [];\n  parent?: HierarchyNode;\n  hgap: number = 0;\n  vgap: number = 0;\n  preH: number;\n  preV: number;\n\n  constructor(data: HierarchyData | HierarchyNode, options: HierarchyOptions) {\n    if (data instanceof Node || ('x' in data && 'y' in data && 'children' in data)) {\n      // If it's already a Node, cast and return\n      const node = data as Node;\n      this.data = node.data;\n      this.id = node.id;\n      this.x = node.x;\n      this.y = node.y;\n      this.width = node.width;\n      this.height = node.height;\n      this.depth = node.depth;\n      this.children = node.children;\n      this.parent = node.parent;\n      this.hgap = node.hgap;\n      this.vgap = node.vgap;\n      this.preH = node.preH;\n      this.preV = node.preV;\n      return;\n    }\n\n    this.data = data as HierarchyData;\n\n    /*\n     * Gaps: filling space between nodes\n     * (x, y) ----------------------\n     * |            vgap            |\n     * |    --------------------    h\n     * | h |                    |   e\n     * | g |                    |   i\n     * | a |                    |   g\n     * | p |                    |   h\n     * |   ---------------------    t\n     * |                            |\n     *  -----------width------------\n     */\n    const hgap = options.getHGap!(data);\n    const vgap = options.getVGap!(data);\n    this.preH = options.getPreH!(data);\n    this.preV = options.getPreV!(data);\n    this.width = options.getWidth!(data);\n    this.height = options.getHeight!(data);\n    this.width += this.preH;\n    this.height += this.preV;\n    this.id = options.getId!(data);\n\n    this.addGap(hgap, vgap);\n  }\n\n  isRoot(): boolean {\n    return this.depth === 0;\n  }\n\n  isLeaf(): boolean {\n    return this.children.length === 0;\n  }\n\n  addGap(hgap: number, vgap: number): void {\n    this.hgap += hgap;\n    this.vgap += vgap;\n    this.width += 2 * hgap;\n    this.height += 2 * vgap;\n  }\n\n  eachNode(callback: (node: HierarchyNode) => void): void {\n    let nodes: HierarchyNode[] = [this];\n    let current: HierarchyNode | undefined;\n    while ((current = nodes.shift())) {\n      callback(current);\n      nodes = current.children.concat(nodes);\n    }\n  }\n\n  DFTraverse(callback: (node: HierarchyNode) => void): void {\n    this.eachNode(callback);\n  }\n\n  BFTraverse(callback: (node: HierarchyNode) => void): void {\n    let nodes: HierarchyNode[] = [this];\n    let current: HierarchyNode | undefined;\n    while ((current = nodes.shift())) {\n      callback(current);\n      nodes = nodes.concat(current.children);\n    }\n  }\n\n  getBoundingBox(): BoundingBox {\n    const bb: BoundingBox = {\n      left: Number.MAX_VALUE,\n      top: Number.MAX_VALUE,\n      width: 0,\n      height: 0,\n    };\n    this.eachNode((node) => {\n      bb.left = Math.min(bb.left, node.x);\n      bb.top = Math.min(bb.top, node.y);\n      bb.width = Math.max(bb.width, node.x + node.width);\n      bb.height = Math.max(bb.height, node.y + node.height);\n    });\n    return bb;\n  }\n\n  translate(tx: number = 0, ty: number = 0): void {\n    this.eachNode((node) => {\n      node.x += tx;\n      node.y += ty;\n      node.x += node.preH;\n      node.y += node.preV;\n    });\n  }\n\n  right2left(): void {\n    const bb = this.getBoundingBox();\n    this.eachNode((node) => {\n      node.x = node.x - (node.x - bb.left) * 2 - node.width;\n    });\n    this.translate(bb.width, 0);\n  }\n\n  bottom2top(): void {\n    const bb = this.getBoundingBox();\n    this.eachNode((node) => {\n      node.y = node.y - (node.y - bb.top) * 2 - node.height;\n    });\n    this.translate(0, bb.height);\n  }\n}\n\nexport default function hierarchy(\n  data: HierarchyData,\n  options: HierarchyOptions = {},\n  isolated?: boolean,\n): HierarchyNode {\n  options = assign({}, DEFAULT_OPTIONS, options);\n  const root = new Node(data, options);\n  const nodes: HierarchyNode[] = [root];\n  let node: HierarchyNode | undefined;\n\n  if (!isolated && !data.collapsed) {\n    while ((node = nodes.shift())) {\n      if (!node.data.collapsed) {\n        const children = options.getChildren!(node.data);\n        const length = children ? children.length : 0;\n        node.children = new Array(length);\n        if (children && length) {\n          for (let i = 0; i < length; i++) {\n            const child = new Node(children[i], options);\n            node.children[i] = child;\n            nodes.push(child);\n            child.parent = node;\n            child.depth = node.depth + 1;\n          }\n        }\n      }\n    }\n  }\n\n  return root;\n}\n","import hierarchy from './hierarchy';\nimport type { HierarchyData, HierarchyNode, HierarchyOptions } from '../types';\n\nexport default class Layout {\n  options: HierarchyOptions;\n  rootNode: HierarchyNode;\n\n  constructor(root: HierarchyData, options: HierarchyOptions = {}) {\n    this.options = options;\n    this.rootNode = hierarchy(root, options);\n  }\n\n  execute(): HierarchyNode {\n    throw new Error('please override this method');\n  }\n}\n","import type { HierarchyNode, HierarchyOptions } from '../types';\n\ninterface WrappedTreeNode {\n  w: number;\n  h: number;\n  y: number;\n  x: number;\n  c: WrappedTreeNode[];\n  cs: number;\n  prelim: number;\n  mod: number;\n  shift: number;\n  change: number;\n  tl: WrappedTreeNode | null;\n  tr: WrappedTreeNode | null;\n  el: WrappedTreeNode | null;\n  er: WrappedTreeNode | null;\n  msel: number;\n  mser: number;\n}\n\nclass WrappedTree implements WrappedTreeNode {\n  w: number;\n  h: number;\n  y: number;\n  x: number = 0;\n  c: WrappedTreeNode[];\n  cs: number;\n  prelim: number = 0;\n  mod: number = 0;\n  shift: number = 0;\n  change: number = 0;\n  tl: WrappedTreeNode | null = null;\n  tr: WrappedTreeNode | null = null;\n  el: WrappedTreeNode | null = null;\n  er: WrappedTreeNode | null = null;\n  msel: number = 0;\n  mser: number = 0;\n\n  constructor(w: number = 0, h: number = 0, y: number = 0, c: WrappedTreeNode[] = []) {\n    this.w = w || 0;\n    this.h = h || 0;\n    this.y = y || 0;\n    this.c = c || [];\n    this.cs = c.length;\n  }\n\n  static fromNode(root: HierarchyNode | null, isHorizontal?: boolean): WrappedTreeNode | null {\n    if (!root) return null;\n    const children: WrappedTreeNode[] = [];\n    root.children.forEach((child) => {\n      const wrappedChild = WrappedTree.fromNode(child, isHorizontal);\n      if (wrappedChild) children.push(wrappedChild);\n    });\n    if (isHorizontal) {\n      return new WrappedTree(root.height, root.width, root.x, children);\n    }\n    return new WrappedTree(root.width, root.height, root.y, children);\n  }\n}\n\nfunction moveRight(node: HierarchyNode, move: number, isHorizontal?: boolean): void {\n  if (isHorizontal) {\n    node.y += move;\n  } else {\n    node.x += move;\n  }\n  node.children.forEach((child) => {\n    moveRight(child, move, isHorizontal);\n  });\n}\n\nfunction getMin(node: HierarchyNode, isHorizontal?: boolean): number {\n  let res = isHorizontal ? node.y : node.x;\n  node.children.forEach((child) => {\n    res = Math.min(getMin(child, isHorizontal), res);\n  });\n  return res;\n}\n\nfunction normalize(node: HierarchyNode, isHorizontal?: boolean): void {\n  const min = getMin(node, isHorizontal);\n  moveRight(node, -min, isHorizontal);\n}\n\nfunction convertBack(\n  converted: WrappedTreeNode,\n  root: HierarchyNode,\n  isHorizontal?: boolean,\n): void {\n  if (isHorizontal) {\n    root.y = converted.x;\n  } else {\n    root.x = converted.x;\n  }\n  converted.c.forEach((child, i) => {\n    convertBack(child, root.children[i], isHorizontal);\n  });\n}\n\nfunction layer(node: HierarchyNode, isHorizontal?: boolean, d: number = 0): void {\n  if (isHorizontal) {\n    node.x = d;\n    d += node.width;\n  } else {\n    node.y = d;\n    d += node.height;\n  }\n  node.children.forEach((child) => {\n    layer(child, isHorizontal, d);\n  });\n}\n\ninterface IYL {\n  low: number;\n  index: number;\n  nxt: IYL | null;\n}\n\nexport default function nonLayeredTidy(\n  root: HierarchyNode,\n  options: HierarchyOptions = {},\n): HierarchyNode {\n  const isHorizontal = options.isHorizontal;\n\n  function firstWalk(t: WrappedTreeNode): void {\n    if (t.cs === 0) {\n      setExtremes(t);\n      return;\n    }\n    firstWalk(t.c[0]);\n    let ih: IYL | null = updateIYL(bottom(t.c[0].el!), 0, null);\n    for (let i = 1; i < t.cs; ++i) {\n      firstWalk(t.c[i]);\n      const min = bottom(t.c[i].er!);\n      separate(t, i, ih);\n      ih = updateIYL(min, i, ih);\n    }\n    positionRoot(t);\n    setExtremes(t);\n  }\n\n  function setExtremes(t: WrappedTreeNode): void {\n    if (t.cs === 0) {\n      t.el = t;\n      t.er = t;\n      t.msel = t.mser = 0;\n    } else {\n      t.el = t.c[0].el;\n      t.msel = t.c[0].msel;\n      t.er = t.c[t.cs - 1].er;\n      t.mser = t.c[t.cs - 1].mser;\n    }\n  }\n\n  function separate(t: WrappedTreeNode, i: number, ih: IYL | null): void {\n    let sr: WrappedTreeNode | null = t.c[i - 1];\n    let mssr = sr.mod;\n    let cl: WrappedTreeNode | null = t.c[i];\n    let mscl = cl.mod;\n    while (sr !== null && cl !== null) {\n      if (ih && bottom(sr) > ih.low) ih = ih.nxt;\n      const dist = mssr + sr.prelim + sr.w - (mscl + cl.prelim);\n      if (dist > 0) {\n        mscl += dist;\n        if (ih) moveSubtree(t, i, ih.index, dist);\n      }\n      const sy = bottom(sr);\n      const cy = bottom(cl);\n      if (sy <= cy) {\n        sr = nextRightContour(sr);\n        if (sr !== null) mssr += sr.mod;\n      }\n      if (sy >= cy) {\n        cl = nextLeftContour(cl);\n        if (cl !== null) mscl += cl.mod;\n      }\n    }\n    if (!sr && !!cl) {\n      setLeftThread(t, i, cl, mscl);\n    } else if (!!sr && !cl) {\n      setRightThread(t, i, sr, mssr);\n    }\n  }\n\n  function moveSubtree(t: WrappedTreeNode, i: number, si: number, dist: number): void {\n    t.c[i].mod += dist;\n    t.c[i].msel += dist;\n    t.c[i].mser += dist;\n    distributeExtra(t, i, si, dist);\n  }\n\n  function nextLeftContour(t: WrappedTreeNode): WrappedTreeNode | null {\n    return t.cs === 0 ? t.tl : t.c[0];\n  }\n\n  function nextRightContour(t: WrappedTreeNode): WrappedTreeNode | null {\n    return t.cs === 0 ? t.tr : t.c[t.cs - 1];\n  }\n\n  function bottom(t: WrappedTreeNode): number {\n    return t.y + t.h;\n  }\n\n  function setLeftThread(\n    t: WrappedTreeNode,\n    i: number,\n    cl: WrappedTreeNode,\n    modsumcl: number,\n  ): void {\n    const li = t.c[0].el!;\n    li.tl = cl;\n    const diff = modsumcl - cl.mod - t.c[0].msel;\n    li.mod += diff;\n    li.prelim -= diff;\n    t.c[0].el = t.c[i].el;\n    t.c[0].msel = t.c[i].msel;\n  }\n\n  function setRightThread(\n    t: WrappedTreeNode,\n    i: number,\n    sr: WrappedTreeNode,\n    modsumsr: number,\n  ): void {\n    const ri = t.c[i].er!;\n    ri.tr = sr;\n    const diff = modsumsr - sr.mod - t.c[i].mser;\n    ri.mod += diff;\n    ri.prelim -= diff;\n    t.c[i].er = t.c[i - 1].er;\n    t.c[i].mser = t.c[i - 1].mser;\n  }\n\n  function positionRoot(t: WrappedTreeNode): void {\n    t.prelim =\n      (t.c[0].prelim + t.c[0].mod + t.c[t.cs - 1].mod + t.c[t.cs - 1].prelim + t.c[t.cs - 1].w) /\n        2 -\n      t.w / 2;\n  }\n\n  function secondWalk(t: WrappedTreeNode, modsum: number): void {\n    modsum += t.mod;\n    t.x = t.prelim + modsum;\n    addChildSpacing(t);\n    for (let i = 0; i < t.cs; i++) {\n      secondWalk(t.c[i], modsum);\n    }\n  }\n\n  function distributeExtra(t: WrappedTreeNode, i: number, si: number, dist: number): void {\n    if (si !== i - 1) {\n      const nr = i - si;\n      t.c[si + 1].shift += dist / nr;\n      t.c[i].shift -= dist / nr;\n      t.c[i].change -= dist - dist / nr;\n    }\n  }\n\n  function addChildSpacing(t: WrappedTreeNode): void {\n    let d = 0;\n    let modsumdelta = 0;\n    for (let i = 0; i < t.cs; i++) {\n      d += t.c[i].shift;\n      modsumdelta += d + t.c[i].change;\n      t.c[i].mod += modsumdelta;\n    }\n  }\n\n  function updateIYL(low: number, index: number, ih: IYL | null): IYL {\n    while (ih !== null && low >= ih.low) {\n      ih = ih.nxt;\n    }\n    return {\n      low,\n      index,\n      nxt: ih,\n    };\n  }\n\n  // do layout\n  layer(root, isHorizontal);\n  const wt = WrappedTree.fromNode(root, isHorizontal);\n  if (wt) {\n    firstWalk(wt);\n    secondWalk(wt, 0);\n    convertBack(wt, root, isHorizontal);\n    normalize(root, isHorizontal);\n  }\n\n  return root;\n}\n","import hierarchy from './hierarchy';\nimport type { HierarchyNode, HierarchyOptions } from '../types';\n\nexport default function separateRoot(\n  root: HierarchyNode,\n  options: HierarchyOptions,\n): { left: HierarchyNode; right: HierarchyNode } {\n  // separate into left and right trees\n  const left = hierarchy(root.data, options, true); // root only\n  const right = hierarchy(root.data, options, true); // root only\n\n  // automatically\n  const treeSize = root.children.length;\n  const rightTreeSize = Math.round(treeSize / 2);\n\n  // separate left and right tree by meta data\n  const getSide =\n    options.getSide ||\n    function (_child: HierarchyNode, index: number): 'left' | 'right' {\n      if (index < rightTreeSize) {\n        return 'right';\n      }\n      return 'left';\n    };\n\n  for (let i = 0; i < treeSize; i++) {\n    const child = root.children[i];\n    const side = getSide(child, i);\n    if (side === 'right') {\n      right.children.push(child);\n    } else {\n      left.children.push(child);\n    }\n  }\n\n  left.eachNode((node) => {\n    if (!node.isRoot()) {\n      node.side = 'left';\n    }\n  });\n\n  right.eachNode((node) => {\n    if (!node.isRoot()) {\n      node.side = 'right';\n    }\n  });\n\n  return {\n    left,\n    right,\n  };\n}\n","import separateTree from './separate-root';\nimport type { HierarchyNode, HierarchyOptions, Direction } from '../types';\n\nconst VALID_DIRECTIONS: Direction[] = [\n  'LR', // left to right\n  'RL', // right to left\n  'TB', // top to bottom\n  'BT', // bottom to top\n  'H', // horizontal\n  'V', // vertical\n];\n\nconst HORIZONTAL_DIRECTIONS: Direction[] = ['LR', 'RL', 'H'];\n\nconst isHorizontal = (direction: Direction): boolean =>\n  HORIZONTAL_DIRECTIONS.indexOf(direction) > -1;\n\nconst DEFAULT_DIRECTION: Direction = VALID_DIRECTIONS[0];\n\ntype LayoutAlgorithm = (root: HierarchyNode, options: HierarchyOptions) => HierarchyNode;\n\nexport default function doLayout(\n  root: HierarchyNode,\n  options: HierarchyOptions,\n  layoutAlgorithm: LayoutAlgorithm,\n): HierarchyNode {\n  const direction = options.direction || DEFAULT_DIRECTION;\n  options.isHorizontal = isHorizontal(direction);\n\n  if (direction && VALID_DIRECTIONS.indexOf(direction) === -1) {\n    throw new TypeError(`Invalid direction: ${direction}`);\n  }\n\n  if (direction === VALID_DIRECTIONS[0]) {\n    // LR\n    layoutAlgorithm(root, options);\n  } else if (direction === VALID_DIRECTIONS[1]) {\n    // RL\n    layoutAlgorithm(root, options);\n    root.right2left();\n  } else if (direction === VALID_DIRECTIONS[2]) {\n    // TB\n    layoutAlgorithm(root, options);\n  } else if (direction === VALID_DIRECTIONS[3]) {\n    // BT\n    layoutAlgorithm(root, options);\n    root.bottom2top();\n  } else if (direction === VALID_DIRECTIONS[4] || direction === VALID_DIRECTIONS[5]) {\n    // H or V\n    // separate into left and right trees\n    const { left, right } = separateTree(root, options);\n    // do layout for left and right trees\n    layoutAlgorithm(left, options);\n    layoutAlgorithm(right, options);\n    if (options.isHorizontal) {\n      left.right2left();\n    } else {\n      left.bottom2top();\n    }\n    // combine left and right trees\n    right.translate(left.x - right.x, left.y - right.y);\n    // translate root\n    root.x = left.x;\n    root.y = right.y;\n    const bb = root.getBoundingBox();\n    if (options.isHorizontal) {\n      if (bb.top < 0) {\n        root.translate(0, -bb.top);\n      }\n    } else {\n      if (bb.left < 0) {\n        root.translate(-bb.left, 0);\n      }\n    }\n  }\n\n  // fixed root position, default value is true\n  let fixedRoot = options.fixedRoot;\n  if (fixedRoot === undefined) fixedRoot = true;\n  if (fixedRoot) {\n    root.translate(-(root.x + root.width / 2 + root.hgap), -(root.y + root.height / 2 + root.vgap));\n  }\n\n  reassignXYIfRadial(root, options);\n\n  return root;\n}\n\nfunction reassignXYIfRadial(root: HierarchyNode, options: HierarchyOptions): void {\n  if (options.radial) {\n    const [rScale, radScale] = options.isHorizontal ? ['x', 'y'] : ['y', 'x'];\n\n    const min = { x: Infinity, y: Infinity };\n    const max = { x: -Infinity, y: -Infinity };\n\n    let count = 0;\n    root.DFTraverse((node) => {\n      count++;\n      const { x, y } = node;\n      min.x = Math.min(min.x, x);\n      min.y = Math.min(min.y, y);\n      max.x = Math.max(max.x, x);\n      max.y = Math.max(max.y, y);\n    });\n\n    const radDiff = max[radScale as 'x' | 'y'] - min[radScale as 'x' | 'y'];\n    if (radDiff === 0) return;\n\n    const avgRad = (Math.PI * 2) / count;\n    root.DFTraverse((node) => {\n      const nodeRadScale = node[radScale as 'x' | 'y'];\n      const minRadScale = min[radScale as 'x' | 'y'];\n      const nodeRScale = node[rScale as 'x' | 'y'];\n      const rootRScale = root[rScale as 'x' | 'y'];\n\n      const rad = ((nodeRadScale - minRadScale) / radDiff) * (Math.PI * 2 - avgRad) + avgRad;\n      const r = nodeRScale - rootRScale;\n      node.x = Math.cos(rad) * r;\n      node.y = Math.sin(rad) * r;\n    });\n  }\n}\n","import TreeLayout from './layout/base';\nimport nonLayeredTidyTree from './layout/non-layered-tidy';\nimport doTreeLayout from './layout/do-layout';\nimport { assign } from './util';\nimport type { HierarchyData, HierarchyNode, CompactBoxOptions } from './types';\n\nclass CompactBoxTreeLayout extends TreeLayout {\n  execute(): HierarchyNode {\n    return doTreeLayout(this.rootNode, this.options, nonLayeredTidyTree);\n  }\n}\n\nconst DEFAULT_OPTIONS: CompactBoxOptions = {};\n\nexport default function compactBoxLayout(\n  root: HierarchyData,\n  options?: CompactBoxOptions,\n): HierarchyNode {\n  const mergedOptions = assign({}, DEFAULT_OPTIONS, options);\n  return new CompactBoxTreeLayout(root, mergedOptions).execute();\n}\n","import { assign } from '../util';\nimport type { HierarchyNode, HierarchyOptions } from '../types';\n\ninterface WrappedTreeNode {\n  x: number;\n  y: number;\n  height: number;\n  leftChild: WrappedTreeNode | null;\n  rightChild: WrappedTreeNode | null;\n  children: WrappedTreeNode[];\n  originNode: HierarchyNode;\n  isLeaf: boolean;\n  drawingDepth?: number;\n}\n\nclass WrappedTree implements WrappedTreeNode {\n  x: number = 0;\n  y: number = 0;\n  height: number;\n  leftChild: WrappedTreeNode | null = null;\n  rightChild: WrappedTreeNode | null = null;\n  children: WrappedTreeNode[];\n  originNode!: HierarchyNode;\n  isLeaf: boolean = false;\n\n  constructor(height: number = 0, children: WrappedTreeNode[] = []) {\n    this.height = height;\n    this.children = children;\n  }\n}\n\nconst DEFAULT_OPTIONS = {\n  isHorizontal: true,\n  nodeSep: 20,\n  nodeSize: 20,\n  rankSep: 200,\n  subTreeSep: 10,\n};\n\nfunction convertBack(converted: WrappedTreeNode, root: HierarchyNode, isHorizontal: boolean): void {\n  if (isHorizontal) {\n    root.x = converted.x;\n    root.y = converted.y;\n  } else {\n    root.x = converted.y;\n    root.y = converted.x;\n  }\n  converted.children.forEach((child, i) => {\n    convertBack(child, root.children[i], isHorizontal);\n  });\n}\n\nexport default function dendrogram(\n  root: HierarchyNode,\n  options: HierarchyOptions = {},\n): HierarchyNode {\n  const mergedOptions = assign({}, DEFAULT_OPTIONS, options);\n\n  let maxDepth = 0;\n\n  function wrappedTreeFromNode(n: HierarchyNode): WrappedTreeNode {\n    n.width = 0;\n    if (n.depth && n.depth > maxDepth) {\n      maxDepth = n.depth;\n    }\n    const children = n.children;\n    const childrenCount = children.length;\n    const t = new WrappedTree(0, []);\n    children.forEach((child, i) => {\n      const childWT = wrappedTreeFromNode(child);\n      t.children.push(childWT);\n      if (i === 0) {\n        t.leftChild = childWT;\n      }\n      if (i === childrenCount - 1) {\n        t.rightChild = childWT;\n      }\n    });\n    t.originNode = n;\n    t.isLeaf = n.isLeaf();\n    return t;\n  }\n\n  function getDrawingDepth(t: WrappedTreeNode): number {\n    if (t.isLeaf || t.children.length === 0) {\n      t.drawingDepth = maxDepth;\n    } else {\n      const depths = t.children.map((child) => getDrawingDepth(child));\n      const minChildDepth = Math.min(...depths);\n      t.drawingDepth = minChildDepth - 1;\n    }\n    return t.drawingDepth;\n  }\n\n  let prevLeaf: WrappedTreeNode | null = null;\n\n  function position(t: WrappedTreeNode): void {\n    t.x = t.drawingDepth! * mergedOptions.rankSep;\n    if (t.isLeaf) {\n      t.y = 0;\n      if (prevLeaf) {\n        t.y = prevLeaf.y + prevLeaf.height + mergedOptions.nodeSep;\n        if (t.originNode.parent !== prevLeaf.originNode.parent) {\n          t.y += mergedOptions.subTreeSep;\n        }\n      }\n      prevLeaf = t;\n    } else {\n      t.children.forEach((child) => {\n        position(child);\n      });\n      t.y = (t.leftChild!.y + t.rightChild!.y) / 2;\n    }\n  }\n\n  const wt = wrappedTreeFromNode(root);\n  getDrawingDepth(wt);\n  position(wt);\n  convertBack(wt, root, mergedOptions.isHorizontal);\n\n  return root;\n}\n","import TreeLayout from './layout/base';\nimport dendrogram from './layout/dendrogram';\nimport doTreeLayout from './layout/do-layout';\nimport { assign } from './util';\nimport type { HierarchyData, HierarchyNode, DendrogramOptions } from './types';\n\nclass DendrogramLayout extends TreeLayout {\n  execute(): HierarchyNode {\n    this.rootNode.width = 0;\n    return doTreeLayout(this.rootNode, this.options, dendrogram);\n  }\n}\n\nconst DEFAULT_OPTIONS: DendrogramOptions = {};\n\nexport default function dendrogramLayout(\n  root: HierarchyData,\n  options?: DendrogramOptions,\n): HierarchyNode {\n  const mergedOptions = assign({}, DEFAULT_OPTIONS, options);\n  return new DendrogramLayout(root, mergedOptions).execute();\n}\n","import { getHeight } from '../util';\nimport type { HierarchyNode } from '../types';\n\nfunction positionNode(\n  node: HierarchyNode,\n  previousNode: HierarchyNode | null,\n  indent: number | ((node: HierarchyNode) => number),\n  dropCap: boolean,\n  align?: 'center' | undefined,\n): void {\n  // calculate the node's horizontal offset DX, dx's type might be number or function\n  const displacementX = (typeof indent === 'function' ? indent(node) : indent) * node.depth;\n\n  if (!dropCap) {\n    try {\n      if (node.parent && node.id === node.parent.children[0].id) {\n        node.x += displacementX;\n        node.y = previousNode ? previousNode.y : 0;\n        return;\n      }\n    } catch {\n      // skip to normal when a node has no parent\n    }\n  }\n\n  node.x += displacementX;\n  if (previousNode) {\n    node.y = previousNode.y + getHeight(previousNode, node, align);\n    if (previousNode.parent && node.parent && node.parent.id !== previousNode.parent.id) {\n      // previous node has different parent\n      const prevParent = previousNode.parent;\n      const preY = prevParent.y + getHeight(prevParent, node, align);\n      node.y = preY > node.y ? preY : node.y;\n    }\n  } else {\n    node.y = 0;\n  }\n}\n\nexport default function indented(\n  root: HierarchyNode,\n  indent: number | ((node: HierarchyNode) => number),\n  dropCap: boolean,\n  align?: 'center' | undefined,\n): void {\n  let previousNode: HierarchyNode | null = null;\n  root.eachNode((node) => {\n    positionNode(node, previousNode, indent, dropCap, align);\n    previousNode = node;\n  });\n}\n","import TreeLayout from './layout/base';\nimport indentedTree from './layout/indented';\nimport separateTree from './layout/separate-root';\nimport { assign } from './util';\nimport type { HierarchyData, HierarchyNode, IndentedOptions, Direction } from './types';\n\nconst VALID_DIRECTIONS: Direction[] = [\n  'LR', // left to right\n  'RL', // right to left\n  'H', // horizontal\n];\nconst DEFAULT_DIRECTION: Direction = VALID_DIRECTIONS[0];\n\nclass IndentedLayout extends TreeLayout {\n  execute(): HierarchyNode {\n    const options = this.options as IndentedOptions;\n    const root = this.rootNode;\n    options.isHorizontal = true;\n\n    // default indent 20 and sink first children;\n    const { indent = 20, dropCap = true, direction = DEFAULT_DIRECTION, align } = options;\n\n    if (direction && VALID_DIRECTIONS.indexOf(direction) === -1) {\n      throw new TypeError(`Invalid direction: ${direction}`);\n    }\n\n    if (direction === VALID_DIRECTIONS[0]) {\n      // LR\n      indentedTree(root, indent, dropCap, align);\n    } else if (direction === VALID_DIRECTIONS[1]) {\n      // RL\n      indentedTree(root, indent, dropCap, align);\n      root.right2left();\n    } else if (direction === VALID_DIRECTIONS[2]) {\n      // H\n      // separate into left and right trees\n      const { left, right } = separateTree(root, options);\n      indentedTree(left, indent, dropCap, align);\n      left.right2left();\n      indentedTree(right, indent, dropCap, align);\n      const bbox = left.getBoundingBox();\n      right.translate(bbox.width, 0);\n      root.x = right.x - root.width / 2;\n    }\n\n    return root;\n  }\n}\n\nconst DEFAULT_OPTIONS: IndentedOptions = {};\n\nexport default function indentedLayout(\n  root: HierarchyData,\n  options?: IndentedOptions,\n): HierarchyNode {\n  const mergedOptions = assign({}, DEFAULT_OPTIONS, options);\n  return new IndentedLayout(root, mergedOptions).execute();\n}\n","import { assign } from '../util';\nimport type { HierarchyNode, HierarchyOptions } from '../types';\n\nfunction secondWalk(node: HierarchyNode, options: HierarchyOptions): number {\n  let totalHeight = 0;\n  if (!node.children.length) {\n    totalHeight = node.height;\n  } else {\n    node.children.forEach((c) => {\n      totalHeight += secondWalk(c, options);\n    });\n  }\n  node._subTreeSep = options.getSubTreeSep!(node.data);\n  node.totalHeight = Math.max(node.height, totalHeight) + 2 * node._subTreeSep;\n  return node.totalHeight;\n}\n\nfunction thirdWalk(node: HierarchyNode): void {\n  const children = node.children;\n  const len = children.length;\n  if (len) {\n    children.forEach((c) => {\n      thirdWalk(c);\n    });\n    const first = children[0];\n    const last = children[len - 1];\n    const childrenHeight = last.y - first.y + last.height;\n    let childrenTotalHeight = 0;\n    children.forEach((child) => {\n      childrenTotalHeight += child.totalHeight!;\n    });\n    if (childrenHeight > node.height) {\n      // 当子节点总高度大于父节点高度\n      node.y = first.y + childrenHeight / 2 - node.height / 2;\n    } else if (children.length !== 1 || node.height > childrenTotalHeight) {\n      // 多于一个子节点或者父节点大于所有子节点的总高度\n      const offset = node.y + (node.height - childrenHeight) / 2 - first.y;\n      children.forEach((c) => {\n        c.translate(0, offset);\n      });\n    } else {\n      // 只有一个子节点\n      node.y = (first.y + first.height / 2 + last.y + last.height / 2) / 2 - node.height / 2;\n    }\n  }\n}\n\nconst DEFAULT_OPTIONS: HierarchyOptions = {\n  getSubTreeSep() {\n    return 0;\n  },\n};\n\nexport default function mindmap(\n  root: HierarchyNode,\n  options: HierarchyOptions = {},\n): HierarchyNode {\n  options = assign({}, DEFAULT_OPTIONS, options);\n\n  root.parent = {\n    x: 0,\n    width: 0,\n    height: 0,\n    y: 0,\n  } as HierarchyNode;\n\n  // first walk\n  root.BFTraverse((node) => {\n    node.x = node.parent!.x + node.parent!.width;\n  });\n\n  root.parent = undefined;\n\n  // second walk\n  secondWalk(root, options);\n\n  // adjusting\n  // separating nodes\n  root.startY = 0;\n  root.y = root.totalHeight! / 2 - root.height / 2;\n  root.eachNode((node) => {\n    const children = node.children;\n    const len = children.length;\n    if (len) {\n      const first = children[0];\n      first.startY = node.startY! + node._subTreeSep!;\n      if (len === 1) {\n        first.y = node.y + node.height / 2 - first.height / 2;\n      } else {\n        first.y = first.startY + first.totalHeight! / 2 - first.height / 2;\n        for (let i = 1; i < len; i++) {\n          const c = children[i];\n          c.startY = children[i - 1].startY! + children[i - 1].totalHeight!;\n          c.y = c.startY + c.totalHeight! / 2 - c.height / 2;\n        }\n      }\n    }\n  });\n\n  // third walk\n  thirdWalk(root);\n\n  return root;\n}\n","import TreeLayout from './layout/base';\nimport mindmap from './layout/mindmap';\nimport doTreeLayout from './layout/do-layout';\nimport { assign } from './util';\nimport type { HierarchyData, HierarchyNode, MindmapOptions } from './types';\n\nclass MindmapLayout extends TreeLayout {\n  execute(): HierarchyNode {\n    return doTreeLayout(this.rootNode, this.options, mindmap);\n  }\n}\n\nconst DEFAULT_OPTIONS: MindmapOptions = {};\n\nexport default function mindmapLayout(\n  root: HierarchyData,\n  options?: MindmapOptions,\n): HierarchyNode {\n  const mergedOptions = assign({}, DEFAULT_OPTIONS, options);\n  return new MindmapLayout(root, mergedOptions).execute();\n}\n","import compactBox from './compact-box';\nimport dendrogram from './dendrogram';\nimport indented from './indented';\nimport mindmap from './mindmap';\n\nexport { compactBox, dendrogram, indented, mindmap };\n\nexport * from './types';\n\nexport default {\n  compactBox,\n  dendrogram,\n  indented,\n  mindmap,\n};\n\nexport const version = '0.7.0';\n"],"names":["getHeight","preNode","node","align","heightField","preNodeHeight","nodeHeight","height","assign","Object","DEFAULT_OPTIONS","getId","d","id","name","getPreH","preH","getPreV","preV","getHGap","hgap","getVGap","vgap","getChildren","children","PEM","getWidth","label","width","split","length","Node","constructor","data","options","this","x","y","depth","parent","addGap","isRoot","isLeaf","eachNode","callback","current","nodes","shift","concat","DFTraverse","BFTraverse","getBoundingBox","bb","left","Number","MAX_VALUE","top","Math","min","max","translate","tx","ty","right2left","bottom2top","hierarchy","isolated","root","collapsed","Array","i","child","push","Layout","rootNode","execute","Error","WrappedTree$1","WrappedTree","w","h","c","prelim","mod","change","tl","tr","el","er","msel","mser","cs","fromNode","isHorizontal","forEach","wrappedChild","moveRight","move","getMin","res","normalize","convertBack","converted","layer","nonLayeredTidy","setExtremes","t","separate","ih","sr","mssr","cl","mscl","bottom","low","nxt","dist","moveSubtree","index","sy","cy","nextRightContour","nextLeftContour","modsumcl","li","diff","setLeftThread","modsumsr","ri","setRightThread","si","nr","distributeExtra","updateIYL","wt","firstWalk","positionRoot","secondWalk","modsum","modsumdelta","addChildSpacing","separateRoot","right","treeSize","rightTreeSize","round","getSide","_child","side","VALID_DIRECTIONS","HORIZONTAL_DIRECTIONS","DEFAULT_DIRECTION","doLayout","layoutAlgorithm","direction","indexOf","TypeError","separateTree","fixedRoot","radial","rScale","radScale","Infinity","count","radDiff","avgRad","PI","nodeRadScale","minRadScale","nodeRScale","rootRScale","rad","r","cos","sin","reassignXYIfRadial","CompactBoxTreeLayout","TreeLayout","doTreeLayout","nonLayeredTidyTree","compactBoxLayout","mergedOptions","leftChild","rightChild","nodeSep","nodeSize","rankSep","subTreeSep","dendrogram","maxDepth","prevLeaf","wrappedTreeFromNode","n","childrenCount","childWT","originNode","getDrawingDepth","drawingDepth","depths","map","minChildDepth","position","DendrogramLayout","dendrogramLayout","indented","indent","dropCap","previousNode","displacementX","prevParent","preY","positionNode","IndentedLayout","indentedTree","bbox","indentedLayout","totalHeight","_subTreeSep","getSubTreeSep","thirdWalk","len","first","last","childrenHeight","childrenTotalHeight","offset","mindmap","startY","MindmapLayout","mindmapLayout","compactBox"],"mappings":"gPAUO,SAASA,EACdC,EACAC,EACAC,EACAC,EAAmC,UAEnC,MAAMC,EAAgBJ,EAAQG,GACxBE,EAAaJ,EAAKE,GACxB,MAAiB,WAAVD,GAAsBE,EAAgBC,GAAc,EAAIL,EAAQM,MACzE,CAEO,MAAMC,EAASC,OAAOD,OCdvBE,EAYF,CACFC,MAAMC,GACIA,EAAEC,IAAMD,EAAEE,KAEpBC,QAAQH,GACCA,EAAEI,MAAQ,EAEnBC,QAAQL,GACCA,EAAEM,MAAQ,EAEnBC,QAAQP,GACCA,EAAEQ,MA3BD,GA6BVC,QAAQT,GACCA,EAAEU,MA9BD,GAgCVC,YAAYX,GACHA,EAAEY,SAEXxB,UAAUY,GACDA,EAAEL,QAnCUkB,GAqCrB,QAAAC,CAASd,GACP,MAAMe,EAAQf,EAAEe,OAAS,IACzB,OAAOf,EAAEgB,OAxCD,GAwCUD,EAAME,MAAM,IAAIC,MACpC,GAGF,MAAMC,EAeJ,WAAAC,CAAYC,EAAqCC,GAC/C,GAbFC,KAAAC,EAAY,EACZD,KAAAE,EAAY,EAGZF,KAAAG,MAAgB,EAChBH,KAAAX,SAA4B,GAE5BW,KAAAf,KAAe,EACfe,KAAAb,KAAe,EAKTW,aAAgBF,GAAS,MAAOE,GAAQ,MAAOA,GAAQ,aAAcA,EAAO,CAE9E,MAAM/B,EAAO+B,EAcb,OAbAE,KAAKF,KAAO/B,EAAK+B,KACjBE,KAAKtB,GAAKX,EAAKW,GACfsB,KAAKC,EAAIlC,EAAKkC,EACdD,KAAKE,EAAInC,EAAKmC,EACdF,KAAKP,MAAQ1B,EAAK0B,MAClBO,KAAK5B,OAASL,EAAKK,OACnB4B,KAAKG,MAAQpC,EAAKoC,MAClBH,KAAKX,SAAWtB,EAAKsB,SACrBW,KAAKI,OAASrC,EAAKqC,OACnBJ,KAAKf,KAAOlB,EAAKkB,KACjBe,KAAKb,KAAOpB,EAAKoB,KACjBa,KAAKnB,KAAOd,EAAKc,UACjBmB,KAAKjB,KAAOhB,EAAKgB,KAEnB,CAEAiB,KAAKF,KAAOA,EAeZ,MAAMb,EAAOc,EAAQf,QAASc,GACxBX,EAAOY,EAAQb,QAASY,GAC9BE,KAAKnB,KAAOkB,EAAQnB,QAASkB,GAC7BE,KAAKjB,KAAOgB,EAAQjB,QAASgB,GAC7BE,KAAKP,MAAQM,EAAQR,SAAUO,GAC/BE,KAAK5B,OAAS2B,EAAQlC,UAAWiC,GACjCE,KAAKP,OAASO,KAAKnB,KACnBmB,KAAK5B,QAAU4B,KAAKjB,KACpBiB,KAAKtB,GAAKqB,EAAQvB,MAAOsB,GAEzBE,KAAKK,OAAOpB,EAAME,EACpB,CAEA,MAAAmB,GACE,OAAsB,IAAfN,KAAKG,KACd,CAEA,MAAAI,GACE,OAAgC,IAAzBP,KAAKX,SAASM,MACvB,CAEA,MAAAU,CAAOpB,EAAcE,GACnBa,KAAKf,MAAQA,EACbe,KAAKb,MAAQA,EACba,KAAKP,OAAS,EAAIR,EAClBe,KAAK5B,QAAU,EAAIe,CACrB,CAEA,QAAAqB,CAASC,GACP,IACIC,EADAC,EAAyB,CAACX,MAE9B,KAAQU,EAAUC,EAAMC,SACtBH,EAASC,GACTC,EAAQD,EAAQrB,SAASwB,OAAOF,EAEpC,CAEA,UAAAG,CAAWL,GACTT,KAAKQ,SAASC,EAChB,CAEA,UAAAM,CAAWN,GACT,IACIC,EADAC,EAAyB,CAACX,MAE9B,KAAQU,EAAUC,EAAMC,SACtBH,EAASC,GACTC,EAAQA,EAAME,OAAOH,EAAQrB,SAEjC,CAEA,cAAA2B,GACE,MAAMC,EAAkB,CACtBC,KAAMC,OAAOC,UACbC,IAAKF,OAAOC,UACZ3B,MAAO,EACPrB,OAAQ,GAQV,OANA4B,KAAKQ,SAAUzC,IACbkD,EAAGC,KAAOI,KAAKC,IAAIN,EAAGC,KAAMnD,EAAKkC,GACjCgB,EAAGI,IAAMC,KAAKC,IAAIN,EAAGI,IAAKtD,EAAKmC,GAC/Be,EAAGxB,MAAQ6B,KAAKE,IAAIP,EAAGxB,MAAO1B,EAAKkC,EAAIlC,EAAK0B,OAC5CwB,EAAG7C,OAASkD,KAAKE,IAAIP,EAAG7C,OAAQL,EAAKmC,EAAInC,EAAKK,UAEzC6C,CACT,CAEA,SAAAQ,CAAUC,EAAa,EAAGC,EAAa,GACrC3B,KAAKQ,SAAUzC,IACbA,EAAKkC,GAAKyB,EACV3D,EAAKmC,GAAKyB,EACV5D,EAAKkC,GAAKlC,EAAKc,KACfd,EAAKmC,GAAKnC,EAAKgB,MAEnB,CAEA,UAAA6C,GACE,MAAMX,EAAKjB,KAAKgB,iBAChBhB,KAAKQ,SAAUzC,IACbA,EAAKkC,EAAIlC,EAAKkC,EAAyB,GAApBlC,EAAKkC,EAAIgB,EAAGC,MAAYnD,EAAK0B,QAElDO,KAAKyB,UAAUR,EAAGxB,MAAO,EAC3B,CAEA,UAAAoC,GACE,MAAMZ,EAAKjB,KAAKgB,iBAChBhB,KAAKQ,SAAUzC,IACbA,EAAKmC,EAAInC,EAAKmC,EAAwB,GAAnBnC,EAAKmC,EAAIe,EAAGI,KAAWtD,EAAKK,SAEjD4B,KAAKyB,UAAU,EAAGR,EAAG7C,OACvB,EAGF,SAAwB0D,EACtBhC,EACAC,EAA4B,CAAA,EAC5BgC,GAEAhC,EAAU1B,EAAO,GAAIE,EAAiBwB,GACtC,MAAMiC,EAAO,IAAIpC,EAAKE,EAAMC,GACtBY,EAAyB,CAACqB,GAChC,IAAIjE,EAEJ,IAAKgE,IAAajC,EAAKmC,UACrB,KAAQlE,EAAO4C,EAAMC,SACnB,IAAK7C,EAAK+B,KAAKmC,UAAW,CACxB,MAAM5C,EAAWU,EAAQX,YAAarB,EAAK+B,MACrCH,EAASN,EAAWA,EAASM,OAAS,EAE5C,GADA5B,EAAKsB,SAAW,IAAI6C,MAAMvC,GACtBN,GAAYM,EACd,IAAA,IAASwC,EAAI,EAAGA,EAAIxC,EAAQwC,IAAK,CAC/B,MAAMC,EAAQ,IAAIxC,EAAKP,EAAS8C,GAAIpC,GACpChC,EAAKsB,SAAS8C,GAAKC,EACnBzB,EAAM0B,KAAKD,GACXA,EAAMhC,OAASrC,EACfqE,EAAMjC,MAAQpC,EAAKoC,MAAQ,CAC7B,CAEJ,CAIJ,OAAO6B,CACT,CCxNA,MAAqBM,EAInB,WAAAzC,CAAYmC,EAAqBjC,EAA4B,IAC3DC,KAAKD,QAAUA,EACfC,KAAKuC,SAAWT,EAAUE,EAAMjC,EAClC,CAEA,OAAAyC,GACE,MAAM,IAAIC,MAAM,8BAClB,ECOF,IAAAC,EAAA,MAAMC,EAkBJ,WAAA9C,CAAY+C,EAAY,EAAGC,EAAY,EAAG3C,EAAY,EAAG4C,EAAuB,IAdhF9C,KAAAC,EAAY,EAGZD,KAAA+C,OAAiB,EACjB/C,KAAAgD,IAAc,EACdhD,KAAAY,MAAgB,EAChBZ,KAAAiD,OAAiB,EACjBjD,KAAAkD,GAA6B,KAC7BlD,KAAAmD,GAA6B,KAC7BnD,KAAAoD,GAA6B,KAC7BpD,KAAAqD,GAA6B,KAC7BrD,KAAAsD,KAAe,EACftD,KAAAuD,KAAe,EAGbvD,KAAK4C,EAAIA,GAAK,EACd5C,KAAK6C,EAAIA,GAAK,EACd7C,KAAKE,EAAIA,GAAK,EACdF,KAAK8C,EAAIA,GAAK,GACd9C,KAAKwD,GAAKV,EAAEnD,MACd,CAEA,eAAO8D,CAASzB,EAA4B0B,GAC1C,IAAK1B,EAAM,OAAO,KAClB,MAAM3C,EAA8B,GAKpC,OAJA2C,EAAK3C,SAASsE,QAASvB,IACrB,MAAMwB,EAAejB,EAAYc,SAASrB,EAAOsB,GAC7CE,GAAcvE,EAASgD,KAAKuB,KAE9BF,EACK,IAAIf,EAAYX,EAAK5D,OAAQ4D,EAAKvC,MAAOuC,EAAK/B,EAAGZ,GAEnD,IAAIsD,EAAYX,EAAKvC,MAAOuC,EAAK5D,OAAQ4D,EAAK9B,EAAGb,EAC1D,GAGF,SAASwE,EAAU9F,EAAqB+F,EAAcJ,GAChDA,EACF3F,EAAKmC,GAAK4D,EAEV/F,EAAKkC,GAAK6D,EAEZ/F,EAAKsB,SAASsE,QAASvB,IACrByB,EAAUzB,EAAO0B,EAAMJ,IAE3B,CAEA,SAASK,EAAOhG,EAAqB2F,GACnC,IAAIM,EAAMN,EAAe3F,EAAKmC,EAAInC,EAAKkC,EAIvC,OAHAlC,EAAKsB,SAASsE,QAASvB,IACrB4B,EAAM1C,KAAKC,IAAIwC,EAAO3B,EAAOsB,GAAeM,KAEvCA,CACT,CAEA,SAASC,EAAUlG,EAAqB2F,GAEtCG,EAAU9F,GADEgG,EAAOhG,EAAM2F,GACHA,EACxB,CAEA,SAASQ,EACPC,EACAnC,EACA0B,GAEIA,EACF1B,EAAK9B,EAAIiE,EAAUlE,EAEnB+B,EAAK/B,EAAIkE,EAAUlE,EAErBkE,EAAUrB,EAAEa,QAAQ,CAACvB,EAAOD,KAC1B+B,EAAY9B,EAAOJ,EAAK3C,SAAS8C,GAAIuB,IAEzC,CAEA,SAASU,EAAMrG,EAAqB2F,EAAwBjF,EAAY,GAClEiF,GACF3F,EAAKkC,EAAIxB,EACTA,GAAKV,EAAK0B,QAEV1B,EAAKmC,EAAIzB,EACTA,GAAKV,EAAKK,QAEZL,EAAKsB,SAASsE,QAASvB,IACrBgC,EAAMhC,EAAOsB,EAAcjF,IAE/B,CAQA,SAAwB4F,EACtBrC,EACAjC,EAA4B,IAE5B,MAAM2D,EAAe3D,EAAQ2D,aAmB7B,SAASY,EAAYC,GACN,IAATA,EAAEf,IACJe,EAAEnB,GAAKmB,EACPA,EAAElB,GAAKkB,EACPA,EAAEjB,KAAOiB,EAAEhB,KAAO,IAElBgB,EAAEnB,GAAKmB,EAAEzB,EAAE,GAAGM,GACdmB,EAAEjB,KAAOiB,EAAEzB,EAAE,GAAGQ,KAChBiB,EAAElB,GAAKkB,EAAEzB,EAAEyB,EAAEf,GAAK,GAAGH,GACrBkB,EAAEhB,KAAOgB,EAAEzB,EAAEyB,EAAEf,GAAK,GAAGD,KAE3B,CAEA,SAASiB,EAASD,EAAoBpC,EAAWsC,GAC/C,IAAIC,EAA6BH,EAAEzB,EAAEX,EAAI,GACrCwC,EAAOD,EAAG1B,IACV4B,EAA6BL,EAAEzB,EAAEX,GACjC0C,EAAOD,EAAG5B,IACd,KAAc,OAAP0B,GAAsB,OAAPE,GAAa,CAC7BH,GAAMK,EAAOJ,GAAMD,EAAGM,QAAUN,EAAGO,KACvC,MAAMC,EAAON,EAAOD,EAAG3B,OAAS2B,EAAG9B,GAAKiC,EAAOD,EAAG7B,QAC9CkC,EAAO,IACTJ,GAAQI,EACJR,GAAIS,EAAYX,EAAGpC,EAAGsC,EAAGU,MAAOF,IAEtC,MAAMG,EAAKN,EAAOJ,GACZW,EAAKP,EAAOF,GACdQ,GAAMC,IACRX,EAAKY,EAAiBZ,GACX,OAAPA,IAAaC,GAAQD,EAAG1B,MAE1BoC,GAAMC,IACRT,EAAKW,EAAgBX,GACV,OAAPA,IAAaC,GAAQD,EAAG5B,KAEhC,EACK0B,GAAQE,EA0Bf,SACEL,EACApC,EACAyC,EACAY,GAEA,MAAMC,EAAKlB,EAAEzB,EAAE,GAAGM,GAClBqC,EAAGvC,GAAK0B,EACR,MAAMc,EAAOF,EAAWZ,EAAG5B,IAAMuB,EAAEzB,EAAE,GAAGQ,KACxCmC,EAAGzC,KAAO0C,EACVD,EAAG1C,QAAU2C,EACbnB,EAAEzB,EAAE,GAAGM,GAAKmB,EAAEzB,EAAEX,GAAGiB,GACnBmB,EAAEzB,EAAE,GAAGQ,KAAOiB,EAAEzB,EAAEX,GAAGmB,IACvB,CAtCIqC,CAAcpB,EAAGpC,EAAGyC,EAAIC,GACbH,IAAOE,GAuCtB,SACEL,EACApC,EACAuC,EACAkB,GAEA,MAAMC,EAAKtB,EAAEzB,EAAEX,GAAGkB,GAClBwC,EAAG1C,GAAKuB,EACR,MAAMgB,EAAOE,EAAWlB,EAAG1B,IAAMuB,EAAEzB,EAAEX,GAAGoB,KACxCsC,EAAG7C,KAAO0C,EACVG,EAAG9C,QAAU2C,EACbnB,EAAEzB,EAAEX,GAAGkB,GAAKkB,EAAEzB,EAAEX,EAAI,GAAGkB,GACvBkB,EAAEzB,EAAEX,GAAGoB,KAAOgB,EAAEzB,EAAEX,EAAI,GAAGoB,IAC3B,CAnDIuC,CAAevB,EAAGpC,EAAGuC,EAAIC,EAE7B,CAEA,SAASO,EAAYX,EAAoBpC,EAAW4D,EAAYd,GAC9DV,EAAEzB,EAAEX,GAAGa,KAAOiC,EACdV,EAAEzB,EAAEX,GAAGmB,MAAQ2B,EACfV,EAAEzB,EAAEX,GAAGoB,MAAQ0B,EA8DjB,SAAyBV,EAAoBpC,EAAW4D,EAAYd,GAClE,GAAIc,IAAO5D,EAAI,EAAG,CAChB,MAAM6D,EAAK7D,EAAI4D,EACfxB,EAAEzB,EAAEiD,EAAK,GAAGnF,OAASqE,EAAOe,EAC5BzB,EAAEzB,EAAEX,GAAGvB,OAASqE,EAAOe,EACvBzB,EAAEzB,EAAEX,GAAGc,QAAUgC,EAAOA,EAAOe,CACjC,CACF,CApEEC,CAAgB1B,EAAGpC,EAAG4D,EAAId,EAC5B,CAEA,SAASM,EAAgBhB,GACvB,OAAgB,IAATA,EAAEf,GAAWe,EAAErB,GAAKqB,EAAEzB,EAAE,EACjC,CAEA,SAASwC,EAAiBf,GACxB,OAAgB,IAATA,EAAEf,GAAWe,EAAEpB,GAAKoB,EAAEzB,EAAEyB,EAAEf,GAAK,EACxC,CAEA,SAASsB,EAAOP,GACd,OAAOA,EAAErE,EAAIqE,EAAE1B,CACjB,CAmEA,SAASqD,EAAUnB,EAAaI,EAAeV,GAC7C,KAAc,OAAPA,GAAeM,GAAON,EAAGM,KAC9BN,EAAKA,EAAGO,IAEV,MAAO,CACLD,MACAI,MAAAA,EACAH,IAAKP,EAET,CAGAL,EAAMpC,EAAM0B,GACZ,MAAMyC,EAAKxD,EAAYc,SAASzB,EAAM0B,GAQtC,OAPIyC,KA9JJ,SAASC,EAAU7B,GACjB,GAAa,IAATA,EAAEf,GAEJ,YADAc,EAAYC,GAGd6B,EAAU7B,EAAEzB,EAAE,IACd,IAAI2B,EAAiByB,EAAUpB,EAAOP,EAAEzB,EAAE,GAAGM,IAAM,EAAG,MACtD,IAAA,IAASjB,EAAI,EAAGA,EAAIoC,EAAEf,KAAMrB,EAAG,CAC7BiE,EAAU7B,EAAEzB,EAAEX,IACd,MAAMZ,EAAMuD,EAAOP,EAAEzB,EAAEX,GAAGkB,IAC1BmB,EAASD,EAAGpC,EAAGsC,GACfA,EAAKyB,EAAU3E,EAAKY,EAAGsC,EACzB,EAiGF,SAAsBF,GACpBA,EAAExB,QACCwB,EAAEzB,EAAE,GAAGC,OAASwB,EAAEzB,EAAE,GAAGE,IAAMuB,EAAEzB,EAAEyB,EAAEf,GAAK,GAAGR,IAAMuB,EAAEzB,EAAEyB,EAAEf,GAAK,GAAGT,OAASwB,EAAEzB,EAAEyB,EAAEf,GAAK,GAAGZ,GACrF,EACF2B,EAAE3B,EAAI,CACV,CArGEyD,CAAa9B,GACbD,EAAYC,EACd,CAgJE6B,CAAUD,GA3CZ,SAASG,EAAW/B,EAAoBgC,GACtCA,GAAUhC,EAAEvB,IACZuB,EAAEtE,EAAIsE,EAAExB,OAASwD,EAgBnB,SAAyBhC,GACvB,IAAI9F,EAAI,EACJ+H,EAAc,EAClB,IAAA,IAASrE,EAAI,EAAGA,EAAIoC,EAAEf,GAAIrB,IACxB1D,GAAK8F,EAAEzB,EAAEX,GAAGvB,MACZ4F,GAAe/H,EAAI8F,EAAEzB,EAAEX,GAAGc,OAC1BsB,EAAEzB,EAAEX,GAAGa,KAAOwD,CAElB,CAvBEC,CAAgBlC,GAChB,IAAA,IAASpC,EAAI,EAAGA,EAAIoC,EAAEf,GAAIrB,IACxBmE,EAAW/B,EAAEzB,EAAEX,GAAIoE,EAEvB,CAqCED,CAAWH,EAAI,GACfjC,EAAYiC,EAAInE,EAAM0B,GACtBO,EAAUjC,EAAM0B,IAGX1B,CACT,CChSA,SAAwB0E,EACtB1E,EACAjC,GAGA,MAAMmB,EAAOY,EAAUE,EAAKlC,KAAMC,GAAS,GACrC4G,EAAQ7E,EAAUE,EAAKlC,KAAMC,GAAS,GAGtC6G,EAAW5E,EAAK3C,SAASM,OACzBkH,EAAgBvF,KAAKwF,MAAMF,EAAW,GAGtCG,EACJhH,EAAQgH,SACR,SAAUC,EAAuB7B,GAC/B,OAAIA,EAAQ0B,EACH,QAEF,MACT,EAEF,IAAA,IAAS1E,EAAI,EAAGA,EAAIyE,EAAUzE,IAAK,CACjC,MAAMC,EAAQJ,EAAK3C,SAAS8C,GAEf,UADA4E,EAAQ3E,EAAOD,GAE1BwE,EAAMtH,SAASgD,KAAKD,GAEpBlB,EAAK7B,SAASgD,KAAKD,EAEvB,CAcA,OAZAlB,EAAKV,SAAUzC,IACRA,EAAKuC,WACRvC,EAAKkJ,KAAO,UAIhBN,EAAMnG,SAAUzC,IACTA,EAAKuC,WACRvC,EAAKkJ,KAAO,WAIT,CACL/F,OACAyF,QAEJ,CChDA,MAAMO,EAAgC,CACpC,KACA,KACA,KACA,KACA,IACA,KAGIC,EAAqC,CAAC,KAAM,KAAM,KAKlDC,EAA+BF,EAAiB,GAItD,SAAwBG,EACtBrF,EACAjC,EACAuH,GAEA,MAAMC,EAAYxH,EAAQwH,WAAaH,EAGvC,GAFArH,EAAQ2D,aAbW,CAAC6D,GACpBJ,EAAsBK,QAAQD,IAAa,EAYpB7D,CAAa6D,GAEhCA,IAAqD,IAAxCL,EAAiBM,QAAQD,GACxC,MAAM,IAAIE,UAAU,sBAAsBF,KAG5C,GAAIA,IAAcL,EAAiB,GAEjCI,EAAgBtF,EAAMjC,QACxB,GAAWwH,IAAcL,EAAiB,GAExCI,EAAgBtF,EAAMjC,GACtBiC,EAAKJ,kBACP,GAAW2F,IAAcL,EAAiB,GAExCI,EAAgBtF,EAAMjC,QACxB,GAAWwH,IAAcL,EAAiB,GAExCI,EAAgBtF,EAAMjC,GACtBiC,EAAKH,kBACP,GAAW0F,IAAcL,EAAiB,IAAMK,IAAcL,EAAiB,GAAI,CAGjF,MAAMhG,KAAEA,EAAAyF,MAAMA,GAAUe,EAAa1F,EAAMjC,GAE3CuH,EAAgBpG,EAAMnB,GACtBuH,EAAgBX,EAAO5G,GACnBA,EAAQ2D,aACVxC,EAAKU,aAELV,EAAKW,aAGP8E,EAAMlF,UAAUP,EAAKjB,EAAI0G,EAAM1G,EAAGiB,EAAKhB,EAAIyG,EAAMzG,GAEjD8B,EAAK/B,EAAIiB,EAAKjB,EACd+B,EAAK9B,EAAIyG,EAAMzG,EACf,MAAMe,EAAKe,EAAKhB,iBACZjB,EAAQ2D,aACNzC,EAAGI,IAAM,GACXW,EAAKP,UAAU,GAAIR,EAAGI,KAGpBJ,EAAGC,KAAO,GACZc,EAAKP,WAAWR,EAAGC,KAAM,EAG/B,CAGA,IAAIyG,EAAY5H,EAAQ4H,UAQxB,YAPkB,IAAdA,IAAyBA,GAAY,GACrCA,GACF3F,EAAKP,YAAYO,EAAK/B,EAAI+B,EAAKvC,MAAQ,EAAIuC,EAAK/C,QAAS+C,EAAK9B,EAAI8B,EAAK5D,OAAS,EAAI4D,EAAK7C,OAQ7F,SAA4B6C,EAAqBjC,GAC/C,GAAIA,EAAQ6H,OAAQ,CAClB,MAAOC,EAAQC,GAAY/H,EAAQ2D,aAAe,CAAC,IAAK,KAAO,CAAC,IAAK,KAE/DnC,EAAM,CAAEtB,EAAG8H,IAAU7H,EAAG6H,KACxBvG,EAAM,CAAEvB,GAAG8H,IAAW7H,GAAG6H,KAE/B,IAAIC,EAAQ,EACZhG,EAAKlB,WAAY/C,IACfiK,IACA,MAAM/H,EAAEA,EAAAC,EAAGA,GAAMnC,EACjBwD,EAAItB,EAAIqB,KAAKC,IAAIA,EAAItB,EAAGA,GACxBsB,EAAIrB,EAAIoB,KAAKC,IAAIA,EAAIrB,EAAGA,GACxBsB,EAAIvB,EAAIqB,KAAKE,IAAIA,EAAIvB,EAAGA,GACxBuB,EAAItB,EAAIoB,KAAKE,IAAIA,EAAItB,EAAGA,KAG1B,MAAM+H,EAAUzG,EAAIsG,GAAyBvG,EAAIuG,GACjD,GAAgB,IAAZG,EAAe,OAEnB,MAAMC,EAAoB,EAAV5G,KAAK6G,GAAUH,EAC/BhG,EAAKlB,WAAY/C,IACf,MAAMqK,EAAerK,EAAK+J,GACpBO,EAAc9G,EAAIuG,GAClBQ,EAAavK,EAAK8J,GAClBU,EAAavG,EAAK6F,GAElBW,GAAQJ,EAAeC,GAAeJ,GAAsB,EAAV3G,KAAK6G,GAASD,GAAUA,EAC1EO,EAAIH,EAAaC,EACvBxK,EAAKkC,EAAIqB,KAAKoH,IAAIF,GAAOC,EACzB1K,EAAKmC,EAAIoB,KAAKqH,IAAIH,GAAOC,GAE7B,CACF,CAtCEG,CAAmB5G,EAAMjC,GAElBiC,CACT,CChFA,MAAM6G,UAA6BC,EACjC,OAAAtG,GACE,OAAOuG,EAAa/I,KAAKuC,SAAUvC,KAAKD,QAASiJ,EACnD,EAGF,MAAMzK,EAAqC,CAAA,EAE3C,SAAwB0K,EACtBjH,EACAjC,GAEA,MAAMmJ,EAAgB7K,EAAO,GAAIE,EAAiBwB,GAClD,OAAO,IAAI8I,EAAqB7G,EAAMkH,GAAe1G,SACvD,CCLA,MAAMG,EAUJ,WAAA9C,CAAYzB,EAAiB,EAAGiB,EAA8B,IAT9DW,KAAAC,EAAY,EACZD,KAAAE,EAAY,EAEZF,KAAAmJ,UAAoC,KACpCnJ,KAAAoJ,WAAqC,KAGrCpJ,KAAAO,QAAkB,EAGhBP,KAAK5B,OAASA,EACd4B,KAAKX,SAAWA,CAClB,EAGF,MAAMd,EAAkB,CACtBmF,cAAc,EACd2F,QAAS,GACTC,SAAU,GACVC,QAAS,IACTC,WAAY,IAGd,SAAStF,EAAYC,EAA4BnC,EAAqB0B,GAChEA,GACF1B,EAAK/B,EAAIkE,EAAUlE,EACnB+B,EAAK9B,EAAIiE,EAAUjE,IAEnB8B,EAAK/B,EAAIkE,EAAUjE,EACnB8B,EAAK9B,EAAIiE,EAAUlE,GAErBkE,EAAU9E,SAASsE,QAAQ,CAACvB,EAAOD,KACjC+B,EAAY9B,EAAOJ,EAAK3C,SAAS8C,GAAIuB,IAEzC,CAEA,SAAwB+F,EACtBzH,EACAjC,EAA4B,IAE5B,MAAMmJ,EAAgB7K,EAAO,GAAIE,EAAiBwB,GAElD,IAAI2J,EAAW,EAoCf,IAAIC,EAAmC,KAqBvC,MAAMxD,EAvDN,SAASyD,EAAoBC,GAC3BA,EAAEpK,MAAQ,EACNoK,EAAE1J,OAAS0J,EAAE1J,MAAQuJ,IACvBA,EAAWG,EAAE1J,OAEf,MAAMd,EAAWwK,EAAExK,SACbyK,EAAgBzK,EAASM,OACzB4E,EAAI,IAAI5B,EAAY,EAAG,IAa7B,OAZAtD,EAASsE,QAAQ,CAACvB,EAAOD,KACvB,MAAM4H,EAAUH,EAAoBxH,GACpCmC,EAAElF,SAASgD,KAAK0H,GACN,IAAN5H,IACFoC,EAAE4E,UAAYY,GAEZ5H,IAAM2H,EAAgB,IACxBvF,EAAE6E,WAAaW,KAGnBxF,EAAEyF,WAAaH,EACftF,EAAEhE,OAASsJ,EAAEtJ,SACNgE,CACT,CAkCWqF,CAAoB5H,GAK/B,OArCA,SAASiI,EAAgB1F,GACvB,GAAIA,EAAEhE,QAAgC,IAAtBgE,EAAElF,SAASM,OACzB4E,EAAE2F,aAAeR,MACZ,CACL,MAAMS,EAAS5F,EAAElF,SAAS+K,IAAKhI,GAAU6H,EAAgB7H,IACnDiI,EAAgB/I,KAAKC,OAAO4I,GAClC5F,EAAE2F,aAAeG,EAAgB,CACnC,CACA,OAAO9F,EAAE2F,YACX,CAwBAD,CAAgB9D,GApBhB,SAASmE,EAAS/F,GAChBA,EAAEtE,EAAIsE,EAAE2F,aAAgBhB,EAAcK,QAClChF,EAAEhE,QACJgE,EAAErE,EAAI,EACFyJ,IACFpF,EAAErE,EAAIyJ,EAASzJ,EAAIyJ,EAASvL,OAAS8K,EAAcG,QAC/C9E,EAAEyF,WAAW5J,SAAWuJ,EAASK,WAAW5J,SAC9CmE,EAAErE,GAAKgJ,EAAcM,aAGzBG,EAAWpF,IAEXA,EAAElF,SAASsE,QAASvB,IAClBkI,EAASlI,KAEXmC,EAAErE,GAAKqE,EAAE4E,UAAWjJ,EAAIqE,EAAE6E,WAAYlJ,GAAK,EAE/C,CAIAoK,CAASnE,GACTjC,EAAYiC,EAAInE,EAAMkH,EAAcxF,cAE7B1B,CACT,CCnHA,MAAMuI,UAAyBzB,EAC7B,OAAAtG,GAEE,OADAxC,KAAKuC,SAAS9C,MAAQ,EACfsJ,EAAa/I,KAAKuC,SAAUvC,KAAKD,QAAS0J,EACnD,EAGF,MAAMlL,EAAqC,CAAA,EAE3C,SAAwBiM,EACtBxI,EACAjC,GAEA,MAAMmJ,EAAgB7K,EAAO,GAAIE,EAAiBwB,GAClD,OAAO,IAAIwK,EAAiBvI,EAAMkH,GAAe1G,SACnD,CCkBA,SAAwBiI,EACtBzI,EACA0I,EACAC,EACA3M,GAEA,IAAI4M,EAAqC,KACzC5I,EAAKxB,SAAUzC,KA3CjB,SACEA,EACA6M,EACAF,EACAC,EACA3M,GAGA,MAAM6M,GAAmC,mBAAXH,EAAwBA,EAAO3M,GAAQ2M,GAAU3M,EAAKoC,MAEpF,IAAKwK,EACH,IACE,GAAI5M,EAAKqC,QAAUrC,EAAKW,KAAOX,EAAKqC,OAAOf,SAAS,GAAGX,GAGrD,OAFAX,EAAKkC,GAAK4K,OACV9M,EAAKmC,EAAI0K,EAAeA,EAAa1K,EAAI,EAG7C,CAAA,MAEA,CAIF,GADAnC,EAAKkC,GAAK4K,EACND,GAEF,GADA7M,EAAKmC,EAAI0K,EAAa1K,EAAIrC,EAAU+M,EAAc7M,EAAMC,GACpD4M,EAAaxK,QAAUrC,EAAKqC,QAAUrC,EAAKqC,OAAO1B,KAAOkM,EAAaxK,OAAO1B,GAAI,CAEnF,MAAMoM,EAAaF,EAAaxK,OAC1B2K,EAAOD,EAAW5K,EAAIrC,EAAUiN,EAAY/M,EAAMC,GACxDD,EAAKmC,EAAI6K,EAAOhN,EAAKmC,EAAI6K,EAAOhN,EAAKmC,CACvC,OAEAnC,EAAKmC,EAAI,CAEb,CAUI8K,CAAajN,EAAM6M,EAAcF,EAAQC,EAAS3M,GAClD4M,EAAe7M,GAEnB,CC5CA,MAAMmJ,EAAgC,CACpC,KACA,KACA,KAEIE,EAA+BF,EAAiB,GAEtD,MAAM+D,UAAuBnC,EAC3B,OAAAtG,GACE,MAAMzC,EAAUC,KAAKD,QACfiC,EAAOhC,KAAKuC,SAClBxC,EAAQ2D,cAAe,EAGvB,MAAMgH,OAAEA,EAAS,GAAAC,QAAIA,GAAU,YAAMpD,EAAYH,EAAApJ,MAAmBA,GAAU+B,EAE9E,GAAIwH,IAAqD,IAAxCL,EAAiBM,QAAQD,GACxC,MAAM,IAAIE,UAAU,sBAAsBF,KAG5C,GAAIA,IAAcL,EAAiB,GAEjCgE,EAAalJ,EAAM0I,EAAQC,EAAS3M,QACtC,GAAWuJ,IAAcL,EAAiB,GAExCgE,EAAalJ,EAAM0I,EAAQC,EAAS3M,GACpCgE,EAAKJ,kBACP,GAAW2F,IAAcL,EAAiB,GAAI,CAG5C,MAAMhG,KAAEA,EAAAyF,MAAMA,GAAUe,EAAa1F,EAAMjC,GAC3CmL,EAAahK,EAAMwJ,EAAQC,EAAS3M,GACpCkD,EAAKU,aACLsJ,EAAavE,EAAO+D,EAAQC,EAAS3M,GACrC,MAAMmN,EAAOjK,EAAKF,iBAClB2F,EAAMlF,UAAU0J,EAAK1L,MAAO,GAC5BuC,EAAK/B,EAAI0G,EAAM1G,EAAI+B,EAAKvC,MAAQ,CAClC,CAEA,OAAOuC,CACT,EAGF,MAAMzD,EAAmC,CAAA,EAEzC,SAAwB6M,EACtBpJ,EACAjC,GAEA,MAAMmJ,EAAgB7K,EAAO,GAAIE,EAAiBwB,GAClD,OAAO,IAAIkL,EAAejJ,EAAMkH,GAAe1G,SACjD,CCtDA,SAAS8D,EAAWvI,EAAqBgC,GACvC,IAAIsL,EAAc,EAUlB,OATKtN,EAAKsB,SAASM,OAGjB5B,EAAKsB,SAASsE,QAASb,IACrBuI,GAAe/E,EAAWxD,EAAG/C,KAH/BsL,EAActN,EAAKK,OAMrBL,EAAKuN,YAAcvL,EAAQwL,cAAexN,EAAK+B,MAC/C/B,EAAKsN,YAAc/J,KAAKE,IAAIzD,EAAKK,OAAQiN,GAAe,EAAItN,EAAKuN,YAC1DvN,EAAKsN,WACd,CAEA,SAASG,EAAUzN,GACjB,MAAMsB,EAAWtB,EAAKsB,SAChBoM,EAAMpM,EAASM,OACrB,GAAI8L,EAAK,CACPpM,EAASsE,QAASb,IAChB0I,EAAU1I,KAEZ,MAAM4I,EAAQrM,EAAS,GACjBsM,EAAOtM,EAASoM,EAAM,GACtBG,EAAiBD,EAAKzL,EAAIwL,EAAMxL,EAAIyL,EAAKvN,OAC/C,IAAIyN,EAAsB,EAI1B,GAHAxM,EAASsE,QAASvB,IAChByJ,GAAuBzJ,EAAMiJ,cAE3BO,EAAiB7N,EAAKK,OAExBL,EAAKmC,EAAIwL,EAAMxL,EAAI0L,EAAiB,EAAI7N,EAAKK,OAAS,UACzB,IAApBiB,EAASM,QAAgB5B,EAAKK,OAASyN,EAAqB,CAErE,MAAMC,EAAS/N,EAAKmC,GAAKnC,EAAKK,OAASwN,GAAkB,EAAIF,EAAMxL,EACnEb,EAASsE,QAASb,IAChBA,EAAErB,UAAU,EAAGqK,IAEnB,MAEE/N,EAAKmC,GAAKwL,EAAMxL,EAAIwL,EAAMtN,OAAS,EAAIuN,EAAKzL,EAAIyL,EAAKvN,OAAS,GAAK,EAAIL,EAAKK,OAAS,CAEzF,CACF,CAEA,MAAMG,EAAoC,CACxCgN,cAAA,IACS,GAIX,SAAwBQ,EACtB/J,EACAjC,EAA4B,IA+C5B,OA7CAA,EAAU1B,EAAO,GAAIE,EAAiBwB,GAEtCiC,EAAK5B,OAAS,CACZH,EAAG,EACHR,MAAO,EACPrB,OAAQ,EACR8B,EAAG,GAIL8B,EAAKjB,WAAYhD,IACfA,EAAKkC,EAAIlC,EAAKqC,OAAQH,EAAIlC,EAAKqC,OAAQX,QAGzCuC,EAAK5B,YAAS,EAGdkG,EAAWtE,EAAMjC,GAIjBiC,EAAKgK,OAAS,EACdhK,EAAK9B,EAAI8B,EAAKqJ,YAAe,EAAIrJ,EAAK5D,OAAS,EAC/C4D,EAAKxB,SAAUzC,IACb,MAAMsB,EAAWtB,EAAKsB,SAChBoM,EAAMpM,EAASM,OACrB,GAAI8L,EAAK,CACP,MAAMC,EAAQrM,EAAS,GAEvB,GADAqM,EAAMM,OAASjO,EAAKiO,OAAUjO,EAAKuN,YACvB,IAARG,EACFC,EAAMxL,EAAInC,EAAKmC,EAAInC,EAAKK,OAAS,EAAIsN,EAAMtN,OAAS,MAC/C,CACLsN,EAAMxL,EAAIwL,EAAMM,OAASN,EAAML,YAAe,EAAIK,EAAMtN,OAAS,EACjE,IAAA,IAAS+D,EAAI,EAAGA,EAAIsJ,EAAKtJ,IAAK,CAC5B,MAAMW,EAAIzD,EAAS8C,GACnBW,EAAEkJ,OAAS3M,EAAS8C,EAAI,GAAG6J,OAAU3M,EAAS8C,EAAI,GAAGkJ,YACrDvI,EAAE5C,EAAI4C,EAAEkJ,OAASlJ,EAAEuI,YAAe,EAAIvI,EAAE1E,OAAS,CACnD,CACF,CACF,IAIFoN,EAAUxJ,GAEHA,CACT,CCjGA,MAAMiK,UAAsBnD,EAC1B,OAAAtG,GACE,OAAOuG,EAAa/I,KAAKuC,SAAUvC,KAAKD,QAASgM,EACnD,EAGF,MAAMxN,EAAkC,CAAA,EAExC,SAAwB2N,EACtBlK,EACAjC,GAEA,MAAMmJ,EAAgB7K,EAAO,GAAIE,EAAiBwB,GAClD,OAAO,IAAIkM,EAAcjK,EAAMkH,GAAe1G,SAChD,CCXA,MAAA2C,EAAe,CAAAgH,WACbA,EAAA1C,WACAA,EAAAgB,SACAA,EAAAsB,QACAA,gFAGqB"}