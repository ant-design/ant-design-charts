"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.build = build;
const pack_shared_1 = require("@utoo/pack-shared");
const child_process_1 = require("child_process");
const fs_1 = __importStar(require("fs"));
const nanoid_1 = require("nanoid");
const path_1 = require("path");
const webpackCompat_1 = require("../config/webpackCompat");
const project_1 = require("../core/project");
const HtmlPlugin_1 = require("../plugins/HtmlPlugin");
const common_1 = require("../utils/common");
const find_root_1 = require("../utils/find-root");
const html_entry_1 = require("../utils/html-entry");
const xcodeProfile_1 = require("../utils/xcodeProfile");
function build(options, projectPath, rootPath) {
    const bundleOptions = (0, webpackCompat_1.resolveBundleOptions)(options, projectPath, rootPath);
    if (!rootPath) {
        // help user to find the rootDir automatically.
        rootPath = (0, find_root_1.findRootDir)(projectPath || process.cwd());
    }
    return buildInternal(bundleOptions, projectPath, rootPath);
}
async function buildInternal(bundleOptions, projectPath, rootPath) {
    var _a, _b, _c, _d, _e, _f;
    (0, common_1.blockStdout)();
    if (process.env.XCODE_PROFILE) {
        await (0, xcodeProfile_1.xcodeProfilingReady)();
    }
    (0, html_entry_1.processHtmlEntry)(bundleOptions.config, projectPath || process.cwd());
    const createProject = (0, project_1.projectFactory)();
    const project = await createProject({
        processEnv: (_a = bundleOptions.processEnv) !== null && _a !== void 0 ? _a : {},
        defineEnv: (0, common_1.createDefineEnv)({
            config: bundleOptions.config,
            dev: (_b = bundleOptions.dev) !== null && _b !== void 0 ? _b : false,
            optionDefineEnv: bundleOptions.defineEnv,
        }),
        watch: {
            enable: false,
        },
        dev: (_c = bundleOptions.dev) !== null && _c !== void 0 ? _c : false,
        buildId: bundleOptions.buildId || (0, nanoid_1.nanoid)(),
        config: {
            ...bundleOptions.config,
            stats: Boolean(process.env.ANALYZE) ||
                bundleOptions.config.stats ||
                bundleOptions.config.entry.some((e) => !!e.html),
        },
        projectPath: projectPath || process.cwd(),
        rootPath: rootPath || projectPath || process.cwd(),
        packPath: (0, common_1.getPackPath)(),
    }, {
        persistentCaching: false,
    });
    const entrypoints = await project.writeAllEntrypointsToDisk();
    (0, pack_shared_1.handleIssues)(entrypoints.issues);
    const htmlConfigs = [
        ...(Array.isArray(bundleOptions.config.html)
            ? bundleOptions.config.html
            : bundleOptions.config.html
                ? [bundleOptions.config.html]
                : []),
        ...bundleOptions.config.entry.filter((e) => !!e.html).map((e) => e.html),
    ];
    if (htmlConfigs.length > 0) {
        const assets = { js: [], css: [] };
        const outputDir = ((_d = bundleOptions.config.output) === null || _d === void 0 ? void 0 : _d.path) || (0, path_1.join)(process.cwd(), "dist");
        if (assets.js.length === 0 && assets.css.length === 0) {
            const statsPath = (0, path_1.join)(outputDir, "stats.json");
            if ((0, fs_1.existsSync)(statsPath)) {
                try {
                    const stats = JSON.parse(fs_1.default.readFileSync(statsPath, "utf-8"));
                    if (stats.assets) {
                        stats.assets.forEach((asset) => {
                            if (asset.name.endsWith(".js"))
                                assets.js.push(asset.name);
                            if (asset.name.endsWith(".css"))
                                assets.css.push(asset.name);
                        });
                    }
                }
                catch (e) {
                    console.warn("Failed to read stats.json for assets discovery", e);
                }
            }
        }
        const publicPath = (_e = bundleOptions.config.output) === null || _e === void 0 ? void 0 : _e.publicPath;
        for (const config of htmlConfigs) {
            const plugin = new HtmlPlugin_1.HtmlPlugin(config);
            await plugin.generate(outputDir, assets, publicPath);
        }
    }
    if (process.env.ANALYZE) {
        await analyzeBundle(((_f = bundleOptions.config.output) === null || _f === void 0 ? void 0 : _f.path) || "dist");
    }
    await project.shutdown();
    // TODO: Maybe run tasks in worker is a better way, see
    // https://github.com/vercel/next.js/blob/512d8283054407ab92b2583ecce3b253c3be7b85/packages/next/src/lib/worker.ts
}
async function analyzeBundle(outputPath) {
    const statsPath = (0, path_1.join)(outputPath, "stats.json");
    if (!(0, fs_1.existsSync)(statsPath)) {
        console.warn(`Stats file not found at ${statsPath}. Make sure to enable stats in your configuration.`);
        return;
    }
    return new Promise((resolve, reject) => {
        const analyzer = (0, child_process_1.spawn)("npx", ["webpack-bundle-analyzer", statsPath], {
            stdio: "inherit",
            shell: true,
        });
        analyzer.on("error", (error) => {
            reject(new Error(`Failed to start bundle analyzer: ${error.message}`));
        });
        analyzer.on("close", () => {
            // The analyzer process has finished, so we can resolve the promise
            // to allow the build process to exit gracefully.
            resolve();
        });
    });
}
