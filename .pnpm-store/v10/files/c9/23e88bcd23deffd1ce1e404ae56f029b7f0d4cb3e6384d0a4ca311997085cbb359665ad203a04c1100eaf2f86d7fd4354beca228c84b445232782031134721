{"version":3,"file":"retry.js","sourceRoot":"","sources":["../../source/types/retry.ts"],"names":[],"mappings":"","sourcesContent":["import type {HttpMethod} from './options.js';\n\nexport type ShouldRetryState = {\n\t/**\n\tThe error that caused the request to fail.\n\t*/\n\terror: Error;\n\n\t/**\n\tThe number of retries attempted. Starts at 1 for the first retry.\n\t*/\n\tretryCount: number;\n};\n\nexport type RetryOptions = {\n\t/**\n\tThe number of times to retry failed requests.\n\n\t@default 2\n\t*/\n\tlimit?: number;\n\n\t/**\n\tThe HTTP methods allowed to retry.\n\n\t@default ['get', 'put', 'head', 'delete', 'options', 'trace']\n\t*/\n\tmethods?: HttpMethod[];\n\n\t/**\n\tThe HTTP status codes allowed to retry.\n\n\t@default [408, 413, 429, 500, 502, 503, 504]\n\t*/\n\tstatusCodes?: number[];\n\n\t/**\n\tThe HTTP status codes allowed to retry with a `Retry-After` header.\n\n\t@default [413, 429, 503]\n\t*/\n\tafterStatusCodes?: number[];\n\n\t/**\n\tIf the `Retry-After` header is greater than `maxRetryAfter`, the request will be canceled.\n\n\t@default Infinity\n\t*/\n\tmaxRetryAfter?: number;\n\n\t/**\n\tThe upper limit of the delay per retry in milliseconds.\n\tTo clamp the delay, set `backoffLimit` to 1000, for example.\n\n\tBy default, the delay is calculated in the following way:\n\n\t```\n\t0.3 * (2 ** (attemptCount - 1)) * 1000\n\t```\n\n\tThe delay increases exponentially.\n\n\t@default Infinity\n\t*/\n\tbackoffLimit?: number;\n\n\t/**\n\tA function to calculate the delay between retries given `attemptCount` (starts from 1).\n\n\t@default attemptCount => 0.3 * (2 ** (attemptCount - 1)) * 1000\n\t*/\n\tdelay?: (attemptCount: number) => number;\n\n\t/**\n\tAdd random jitter to retry delays to prevent thundering herd problems.\n\n\tWhen many clients retry simultaneously (e.g., after hitting a rate limit), they can overwhelm the server again. Jitter adds randomness to break this synchronization.\n\n\tSet to `true` to use full jitter, which randomizes the delay between 0 and the computed delay.\n\n\tAlternatively, pass a function to implement custom jitter strategies.\n\n\t@default undefined (no jitter)\n\n\t@example\n\t```\n\timport ky from 'ky';\n\n\tconst json = await ky('https://example.com', {\n\t\tretry: {\n\t\t\tlimit: 5,\n\n\t\t\t// Full jitter (randomizes delay between 0 and computed value)\n\t\t\tjitter: true\n\n\t\t\t// Percentage jitter (80-120% of delay)\n\t\t\t// jitter: delay => delay * (0.8 + Math.random() * 0.4)\n\n\t\t\t// Absolute jitter (Â±100ms)\n\t\t\t// jitter: delay => delay + (Math.random() * 200 - 100)\n\t\t}\n\t}).json();\n\t```\n\t*/\n\tjitter?: boolean | ((delay: number) => number) | undefined;\n\n\t/**\n\tWhether to retry when the request times out.\n\n\t@default false\n\n\t@example\n\t```\n\timport ky from 'ky';\n\n\tconst json = await ky('https://example.com', {\n\t\tretry: {\n\t\t\tlimit: 3,\n\t\t\tretryOnTimeout: true\n\t\t}\n\t}).json();\n\t```\n\t*/\n\tretryOnTimeout?: boolean;\n\n\t/**\n\tA function to determine whether a retry should be attempted.\n\n\tThis function takes precedence over all other retry checks and is called first, before any other retry validation.\n\n\t**Note:** This is different from the `beforeRetry` hook:\n\t- `shouldRetry`: Controls WHETHER to retry (called before the retry decision is made)\n\t- `beforeRetry`: Called AFTER retry is confirmed, allowing you to modify the request\n\n\tShould return:\n\t- `true` to force a retry (bypasses `retryOnTimeout`, status code checks, and other validations)\n\t- `false` to prevent a retry (no retry will occur)\n\t- `undefined` to use the default retry logic (`retryOnTimeout`, status codes, etc.)\n\n\t@example\n\t```\n\timport ky, {HTTPError} from 'ky';\n\n\tconst json = await ky('https://example.com', {\n\t\tretry: {\n\t\t\tlimit: 3,\n\t\t\tshouldRetry: ({error, retryCount}) => {\n\t\t\t\t// Retry on specific business logic errors from API\n\t\t\t\tif (error instanceof HTTPError) {\n\t\t\t\t\tconst status = error.response.status;\n\n\t\t\t\t\t// Retry on 429 (rate limit) but only for first 2 attempts\n\t\t\t\t\tif (status === 429 && retryCount <= 2) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Don't retry on 4xx errors except rate limits\n\t\t\t\t\tif (status >= 400 && status < 500) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Use default retry logic for other errors\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\t}).json();\n\t```\n\t*/\n\tshouldRetry?: (state: ShouldRetryState) => boolean | undefined | Promise<boolean | undefined>;\n};\n"]}