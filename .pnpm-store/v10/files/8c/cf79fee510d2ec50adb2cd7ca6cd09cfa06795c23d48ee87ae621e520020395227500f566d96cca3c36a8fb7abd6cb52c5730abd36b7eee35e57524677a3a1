"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModuleBuildError = void 0;
exports.processIssues = processIssues;
exports.isWellKnownError = isWellKnownError;
exports.formatIssue = formatIssue;
exports.renderStyledStringToErrorAnsi = renderStyledStringToErrorAnsi;
exports.isRelevantWarning = isRelevantWarning;
exports.rustifyEnv = rustifyEnv;
exports.createDefineEnv = createDefineEnv;
exports.debounce = debounce;
exports.blockStdout = blockStdout;
exports.getPackPath = getPackPath;
const code_frame_1 = require("@babel/code-frame");
const path_1 = __importDefault(require("path"));
const picocolors_1 = require("picocolors");
const magicIdentifier_1 = require("./magicIdentifier");
class ModuleBuildError extends Error {
    constructor() {
        super(...arguments);
        this.name = "ModuleBuildError";
    }
}
exports.ModuleBuildError = ModuleBuildError;
function processIssues(result, throwIssue, logErrors) {
    const relevantIssues = new Set();
    for (const issue of result.issues) {
        if (issue.severity !== "error" &&
            issue.severity !== "fatal" &&
            issue.severity !== "warning")
            continue;
        if (issue.severity !== "warning") {
            if (throwIssue) {
                const formatted = formatIssue(issue);
                relevantIssues.add(formatted);
            }
            // if we throw the issue it will most likely get handed and logged elsewhere
            else if (logErrors && isWellKnownError(issue)) {
                const formatted = formatIssue(issue);
                console.error(formatted);
            }
        }
    }
    if (relevantIssues.size && throwIssue) {
        throw new ModuleBuildError([...relevantIssues].join("\n\n"));
    }
}
function isWellKnownError(issue) {
    const { title } = issue;
    const formattedTitle = renderStyledStringToErrorAnsi(title);
    // TODO: add more well known errors
    if (formattedTitle.includes("Module not found") ||
        formattedTitle.includes("Unknown module type")) {
        return true;
    }
    return false;
}
function formatIssue(issue) {
    const { filePath, title, description, source } = issue;
    let { documentationLink } = issue;
    let formattedTitle = renderStyledStringToErrorAnsi(title).replace(/\n/g, "\n    ");
    let formattedFilePath = filePath
        .replace("[project]/", "./")
        .replaceAll("/./", "/")
        .replace("\\\\?\\", "");
    let message = "";
    if (source && source.range) {
        const { start } = source.range;
        message = `${formattedFilePath}:${start.line + 1}:${start.column + 1}\n${formattedTitle}`;
    }
    else if (formattedFilePath) {
        message = `${formattedFilePath}\n${formattedTitle}`;
    }
    else {
        message = formattedTitle;
    }
    message += "\n";
    if ((source === null || source === void 0 ? void 0 : source.range) && source.source.content) {
        const { start, end } = source.range;
        message +=
            (0, code_frame_1.codeFrameColumns)(source.source.content, {
                start: {
                    line: start.line + 1,
                    column: start.column + 1,
                },
                end: {
                    line: end.line + 1,
                    column: end.column + 1,
                },
            }, { forceColor: true }).trim() + "\n\n";
    }
    if (description) {
        message += renderStyledStringToErrorAnsi(description) + "\n\n";
    }
    // TODO: make it possible to enable this for debugging, but not in tests.
    // if (detail) {
    //   message += renderStyledStringToErrorAnsi(detail) + '\n\n'
    // }
    // TODO: Include a trace from the issue.
    if (documentationLink) {
        message += documentationLink + "\n\n";
    }
    return message;
}
function renderStyledStringToErrorAnsi(string) {
    function decodeMagicIdentifiers(str) {
        return str.replaceAll(magicIdentifier_1.MAGIC_IDENTIFIER_REGEX, (ident) => {
            try {
                return (0, picocolors_1.magenta)(`{${(0, magicIdentifier_1.decodeMagicIdentifier)(ident)}}`);
            }
            catch (e) {
                return (0, picocolors_1.magenta)(`{${ident} (decoding failed: ${e})}`);
            }
        });
    }
    switch (string.type) {
        case "text":
            return decodeMagicIdentifiers(string.value);
        case "strong":
            return (0, picocolors_1.bold)((0, picocolors_1.red)(decodeMagicIdentifiers(string.value)));
        case "code":
            return (0, picocolors_1.green)(decodeMagicIdentifiers(string.value));
        case "line":
            return string.value.map(renderStyledStringToErrorAnsi).join("");
        case "stack":
            return string.value.map(renderStyledStringToErrorAnsi).join("\n");
        default:
            throw new Error("Unknown StyledString type", string);
    }
}
function isRelevantWarning(issue) {
    return issue.severity === "warning" && !isNodeModulesIssue(issue);
}
function isNodeModulesIssue(issue) {
    if (issue.severity === "warning" && issue.stage === "config") {
        // Override for the externalize issue
        // `Package foo (serverExternalPackages or default list) can't be external`
        if (renderStyledStringToErrorAnsi(issue.title).includes("can't be external")) {
            return false;
        }
    }
    return (issue.severity === "warning" &&
        (issue.filePath.match(/^(?:.*[\\/])?node_modules(?:[\\/].*)?$/) !== null ||
            issue.filePath.includes("@utoo/pack")));
}
function rustifyEnv(env) {
    return Object.entries(env)
        .filter(([_, value]) => value != null)
        .map(([name, value]) => ({
        name,
        value,
    }));
}
function createDefineEnv(options) {
    var _a;
    let defineEnv = (_a = options.optionDefineEnv) !== null && _a !== void 0 ? _a : {
        client: [],
        edge: [],
        nodejs: [],
    };
    function getDefineEnv() {
        var _a;
        const envs = {
            "process.env.NODE_ENV": options.dev ? "development" : "production",
        };
        const userDefines = (_a = options.config.define) !== null && _a !== void 0 ? _a : {};
        for (const key in userDefines) {
            envs[key] = userDefines[key];
        }
        // serialize
        const defineEnvStringified = {};
        for (const key in defineEnv) {
            const value = envs[key];
            defineEnvStringified[key] = JSON.stringify(value);
        }
        return defineEnvStringified;
    }
    // TODO: future define envs need to extends for more compiler like server or edge.
    for (const variant of Object.keys(defineEnv)) {
        defineEnv[variant] = rustifyEnv(getDefineEnv());
    }
    return defineEnv;
}
function debounce(fn, ms, maxWait = Infinity) {
    let timeoutId;
    // The time the debouncing function was first called during this debounce queue.
    let startTime = 0;
    // The time the debouncing function was last called.
    let lastCall = 0;
    // The arguments and this context of the last call to the debouncing function.
    let args, context;
    // A helper used to that either invokes the debounced function, or
    // reschedules the timer if a more recent call was made.
    function run() {
        const now = Date.now();
        const diff = lastCall + ms - now;
        // If the diff is non-positive, then we've waited at least `ms`
        // milliseconds since the last call. Or if we've waited for longer than the
        // max wait time, we must call the debounced function.
        if (diff <= 0 || startTime + maxWait >= now) {
            // It's important to clear the timeout id before invoking the debounced
            // function, in case the function calls the debouncing function again.
            timeoutId = undefined;
            fn.apply(context, args);
        }
        else {
            // Else, a new call was made after the original timer was scheduled. We
            // didn't clear the timeout (doing so is very slow), so now we need to
            // reschedule the timer for the time difference.
            timeoutId = setTimeout(run, diff);
        }
    }
    return function (...passedArgs) {
        // The arguments and this context of the most recent call are saved so the
        // debounced function can be invoked with them later.
        args = passedArgs;
        context = this;
        // Instead of constantly clearing and scheduling a timer, we record the
        // time of the last call. If a second call comes in before the timer fires,
        // then we'll reschedule in the run function. Doing this is considerably
        // faster.
        lastCall = Date.now();
        // Only schedule a new timer if we're not currently waiting.
        if (timeoutId === undefined) {
            startTime = lastCall;
            timeoutId = setTimeout(run, ms);
        }
    };
}
// ref:
// https://github.com/vercel/next.js/pull/51883
function blockStdout() {
    // rust needs stdout to be blocking, otherwise it will throw an error (on macOS at least) when writing a lot of data (logs) to it
    // see https://github.com/napi-rs/napi-rs/issues/1630
    // and https://github.com/nodejs/node/blob/main/doc/api/process.md#a-note-on-process-io
    if (process.stdout._handle != null) {
        process.stdout._handle.setBlocking(true);
    }
    if (process.stderr._handle != null) {
        process.stderr._handle.setBlocking(true);
    }
}
function getPackPath() {
    return path_1.default.resolve(__dirname, "..");
}
