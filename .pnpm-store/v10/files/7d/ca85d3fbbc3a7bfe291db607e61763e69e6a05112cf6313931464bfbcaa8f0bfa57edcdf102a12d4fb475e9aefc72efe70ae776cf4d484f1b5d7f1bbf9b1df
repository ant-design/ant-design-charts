import fs from "fs";
import { nanoid } from "nanoid";
import { join } from "path";
import ws from "ws";
import { HtmlPlugin } from "../plugins/HtmlPlugin";
import { createDefineEnv, debounce, getPackPath, processIssues, } from "../utils/common";
import { processHtmlEntry } from "../utils/html-entry";
import { projectFactory } from "./project";
const wsServer = new ws.Server({ noServer: true });
const sessionId = Math.floor(Number.MAX_SAFE_INTEGER * Math.random());
export const FAST_REFRESH_RUNTIME_RELOAD = "Fast Refresh had to perform a full reload due to a runtime error.";
export async function createHotReloader(bundleOptions, projectPath, rootPath) {
    var _a;
    processHtmlEntry(bundleOptions.config, projectPath || process.cwd());
    const createProject = projectFactory();
    const project = await createProject({
        processEnv: (_a = bundleOptions.processEnv) !== null && _a !== void 0 ? _a : {},
        defineEnv: createDefineEnv({
            config: bundleOptions.config,
            dev: true,
            optionDefineEnv: bundleOptions.defineEnv,
        }),
        watch: {
            enable: true,
        },
        dev: true,
        buildId: bundleOptions.buildId || nanoid(),
        config: {
            ...bundleOptions.config,
            mode: "development",
            stats: Boolean(process.env.ANALYZE) ||
                bundleOptions.config.stats ||
                bundleOptions.config.entry.some((e) => !!e.html),
            optimization: {
                ...bundleOptions.config.optimization,
                minify: false,
                moduleIds: "named",
            },
        },
        projectPath: projectPath || process.cwd(),
        rootPath: rootPath || projectPath || process.cwd(),
        packPath: getPackPath(),
    }, {
        persistentCaching: true,
    });
    const entrypointsSubscription = project.entrypointsSubscribe();
    let currentEntriesHandlingResolve;
    let currentEntriesHandling = new Promise((resolve) => (currentEntriesHandlingResolve = resolve));
    let hmrEventHappened = false;
    let hmrHash = 0;
    const clients = new Set();
    const clientStates = new WeakMap();
    function sendToClient(client, payload) {
        client.send(JSON.stringify(payload));
    }
    function sendEnqueuedMessages() {
        for (const client of clients) {
            const state = clientStates.get(client);
            if (!state) {
                continue;
            }
            for (const payload of state.hmrPayloads.values()) {
                sendToClient(client, payload);
            }
            state.hmrPayloads.clear();
            if (state.turbopackUpdates.length > 0) {
                sendToClient(client, {
                    action: "turbopack-message" /* HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_MESSAGE */,
                    data: state.turbopackUpdates,
                });
                state.turbopackUpdates.length = 0;
            }
        }
    }
    const sendEnqueuedMessagesDebounce = debounce(sendEnqueuedMessages, 2);
    function sendTurbopackMessage(payload) {
        var _a;
        payload.diagnostics = [];
        payload.issues = [];
        for (const client of clients) {
            (_a = clientStates.get(client)) === null || _a === void 0 ? void 0 : _a.turbopackUpdates.push(payload);
        }
        hmrEventHappened = true;
        sendEnqueuedMessagesDebounce();
    }
    async function subscribeToHmrEvents(client, id) {
        const state = clientStates.get(client);
        if (!state || state.subscriptions.has(id)) {
            return;
        }
        const subscription = project.hmrEvents(id);
        state.subscriptions.set(id, subscription);
        // The subscription will always emit once, which is the initial
        // computation. This is not a change, so swallow it.
        try {
            await subscription.next();
            for await (const data of subscription) {
                processIssues(data, true, true);
                if (data.type !== "issues") {
                    sendTurbopackMessage(data);
                }
            }
        }
        catch (e) {
            // The client might be using an HMR session from a previous server, tell them
            // to fully reload the page to resolve the issue. We can't use
            // `hotReloader.send` since that would force every connected client to
            // reload, only this client is out of date.
            const reloadAction = {
                action: "reload" /* HMR_ACTIONS_SENT_TO_BROWSER.RELOAD */,
                data: `error in HMR event subscription for ${id}: ${e}`,
            };
            sendToClient(client, reloadAction);
            client.close();
            return;
        }
    }
    function unsubscribeFromHmrEvents(client, id) {
        const state = clientStates.get(client);
        if (!state) {
            return;
        }
        const subscription = state.subscriptions.get(id);
        subscription === null || subscription === void 0 ? void 0 : subscription.return();
    }
    async function handleEntrypointsSubscription() {
        var _a, _b;
        for await (const entrypoints of entrypointsSubscription) {
            if (!currentEntriesHandlingResolve) {
                currentEntriesHandling = new Promise(
                // eslint-disable-next-line no-loop-func
                (resolve) => (currentEntriesHandlingResolve = resolve));
            }
            const assets = { js: [], css: [] };
            await Promise.all(entrypoints.apps.map((l) => l.writeToDisk().then((res) => {
                processIssues(res, true, true);
                res.clientPaths.forEach((p) => {
                    if (p.endsWith(".js"))
                        assets.js.push(p);
                    if (p.endsWith(".css"))
                        assets.css.push(p);
                });
            })));
            const htmlConfigs = [
                ...(Array.isArray(bundleOptions.config.html)
                    ? bundleOptions.config.html
                    : bundleOptions.config.html
                        ? [bundleOptions.config.html]
                        : []),
                ...bundleOptions.config.entry
                    .filter((e) => !!e.html)
                    .map((e) => e.html),
            ];
            if (htmlConfigs.length > 0) {
                const outputDir = ((_a = bundleOptions.config.output) === null || _a === void 0 ? void 0 : _a.path) || join(process.cwd(), "dist");
                const publicPath = (_b = bundleOptions.config.output) === null || _b === void 0 ? void 0 : _b.publicPath;
                if (assets.js.length === 0 && assets.css.length === 0) {
                    const statsPath = join(outputDir, "stats.json");
                    if (fs.existsSync(statsPath)) {
                        try {
                            const stats = JSON.parse(fs.readFileSync(statsPath, "utf-8"));
                            if (stats.assets) {
                                stats.assets.forEach((asset) => {
                                    if (asset.name.endsWith(".js"))
                                        assets.js.push(asset.name);
                                    if (asset.name.endsWith(".css"))
                                        assets.css.push(asset.name);
                                });
                            }
                        }
                        catch (e) {
                            console.warn("Failed to read stats.json for assets discovery", e);
                        }
                    }
                }
                for (const config of htmlConfigs) {
                    const plugin = new HtmlPlugin(config);
                    await plugin.generate(outputDir, assets, publicPath);
                }
            }
            currentEntriesHandlingResolve();
            currentEntriesHandlingResolve = undefined;
        }
    }
    const hotReloader = {
        turbopackProject: project,
        serverStats: null,
        onHMR(req, socket, head, onUpgrade) {
            wsServer.handleUpgrade(req, socket, head, (client) => {
                onUpgrade === null || onUpgrade === void 0 ? void 0 : onUpgrade(client);
                const subscriptions = new Map();
                clients.add(client);
                clientStates.set(client, {
                    hmrPayloads: new Map(),
                    turbopackUpdates: [],
                    subscriptions,
                });
                client.on("close", () => {
                    var _a;
                    // Remove active subscriptions
                    for (const subscription of subscriptions.values()) {
                        (_a = subscription.return) === null || _a === void 0 ? void 0 : _a.call(subscription);
                    }
                    clientStates.delete(client);
                    clients.delete(client);
                });
                client.addEventListener("message", ({ data }) => {
                    const parsedData = JSON.parse(typeof data !== "string" ? data.toString() : data);
                    // messages
                    switch (parsedData.event) {
                        case "client-error": // { errorCount, clientId }
                        case "client-warning": // { warningCount, clientId }
                        case "client-success": // { clientId }
                        case "client-full-reload": // { stackTrace, hadRuntimeError }
                            const { hadRuntimeError, dependencyChain } = parsedData;
                            if (hadRuntimeError) {
                                console.warn(FAST_REFRESH_RUNTIME_RELOAD);
                            }
                            if (Array.isArray(dependencyChain) &&
                                typeof dependencyChain[0] === "string") {
                                const cleanedModulePath = dependencyChain[0]
                                    .replace(/^\[project\]/, ".")
                                    .replace(/ \[.*\] \(.*\)$/, "");
                                console.warn(`Fast Refresh had to perform a full reload when ${cleanedModulePath} changed.`);
                            }
                            break;
                        default:
                            // Might be a Turbopack message...
                            if (!parsedData.type) {
                                throw new Error(`unrecognized HMR message "${data}"`);
                            }
                    }
                    // Turbopack messages
                    switch (parsedData.type) {
                        case "turbopack-subscribe":
                            subscribeToHmrEvents(client, parsedData.path);
                            break;
                        case "turbopack-unsubscribe":
                            unsubscribeFromHmrEvents(client, parsedData.path);
                            break;
                        default:
                            if (!parsedData.event) {
                                throw new Error(`unrecognized Turbopack HMR message "${data}"`);
                            }
                    }
                });
                const turbopackConnected = {
                    action: "turbopack-connected" /* HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_CONNECTED */,
                    data: { sessionId },
                };
                sendToClient(client, turbopackConnected);
                const errors = [];
                (async function () {
                    const sync = {
                        action: "sync" /* HMR_ACTIONS_SENT_TO_BROWSER.SYNC */,
                        errors,
                        warnings: [],
                        hash: "",
                    };
                    sendToClient(client, sync);
                })();
            });
        },
        send(action) {
            const payload = JSON.stringify(action);
            for (const client of clients) {
                client.send(payload);
            }
        },
        setHmrServerError(_error) {
            // Not implemented yet.
        },
        clearHmrServerError() {
            // Not implemented yet.
        },
        async start() { },
        async buildFallbackError() {
            // Not implemented yet.
        },
        close() {
            for (const wsClient of clients) {
                // it's okay to not cleanly close these websocket connections, this is dev
                wsClient.terminate();
            }
            clients.clear();
        },
    };
    handleEntrypointsSubscription().catch((err) => {
        console.error(err);
        process.exit(1);
    });
    // Write empty manifests
    await currentEntriesHandling;
    async function handleProjectUpdates() {
        for await (const updateMessage of project.updateInfoSubscribe(30)) {
            switch (updateMessage.updateType) {
                case "start": {
                    hotReloader.send({ action: "building" /* HMR_ACTIONS_SENT_TO_BROWSER.BUILDING */ });
                    break;
                }
                case "end": {
                    sendEnqueuedMessages();
                    const errors = new Map();
                    for (const client of clients) {
                        const state = clientStates.get(client);
                        if (!state) {
                            continue;
                        }
                        const clientErrors = new Map(errors);
                        sendToClient(client, {
                            action: "built" /* HMR_ACTIONS_SENT_TO_BROWSER.BUILT */,
                            hash: String(++hmrHash),
                            errors: [...clientErrors.values()],
                            warnings: [],
                        });
                    }
                    if (hmrEventHappened) {
                        const time = updateMessage.value.duration;
                        const timeMessage = time > 2000 ? `${Math.round(time / 100) / 10}s` : `${time}ms`;
                        console.log(`Compiled in ${timeMessage}`);
                        hmrEventHappened = false;
                    }
                    break;
                }
                default:
            }
        }
    }
    handleProjectUpdates().catch((err) => {
        console.error(err);
        process.exit(1);
    });
    return hotReloader;
}
