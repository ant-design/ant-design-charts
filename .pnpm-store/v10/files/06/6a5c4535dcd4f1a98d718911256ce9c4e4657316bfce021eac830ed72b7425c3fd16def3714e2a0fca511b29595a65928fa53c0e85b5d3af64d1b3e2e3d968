/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export declare class ExternalObject<T> {
  readonly '': {
    readonly '': unique symbol
    [K: symbol]: T
  }
}
export declare function registerWorkerScheduler(creator: (arg: NapiWorkerCreation) => any, terminator: (arg: NapiWorkerTermination) => any): void
export declare function workerCreated(workerId: number): void
export interface NapiWorkerCreation {
  options: NapiWorkerOptions
}
export interface NapiWorkerOptions {
  filename: RcStr
  cwd: RcStr
}
export interface NapiWorkerTermination {
  options: NapiWorkerOptions
  workerId: number
}
export interface NapiTaskMessage {
  taskId: number
  data: Buffer
}
export declare function recvTaskMessageInWorker(workerId: number): Promise<NapiTaskMessage>
export declare function sendTaskMessage(message: NapiTaskMessage): Promise<void>
export interface NapiEndpointConfig {
  
}
export interface NapiServerPath {
  path: string
  contentHash: string
}
export interface NapiWrittenEndpoint {
  type: string
  entryPath?: string
  clientPaths: Array<string>
  serverPaths: Array<NapiServerPath>
  config: NapiEndpointConfig
}
export declare function endpointWriteToDisk(endpoint: { __napiType: "Endpoint" }): Promise<TurbopackResult>
export declare function endpointServerChangedSubscribe(endpoint: { __napiType: "Endpoint" }, issues: boolean, func: (...args: any[]) => any): { __napiType: "RootTask" }
export declare function endpointClientChangedSubscribe(endpoint: { __napiType: "Endpoint" }, func: (...args: any[]) => any): { __napiType: "RootTask" }
export interface NapiEnvVar {
  name: string
  value: string
}
export interface NapiWatchOptions {
  /** Whether to watch the filesystem for file changes. */
  enable: boolean
  /**
   * Enable polling at a certain interval if the native file watching doesn't work (e.g.
   * docker).
   */
  pollIntervalMs?: number
}
export interface NapiProjectOptions {
  /**
   * A root path from which all files must be nested under. Trying to access
   * a file outside this root will fail. Think of this as a chroot.
   */
  rootPath: string
  /** A path inside the root_path which contains the app/pages directories. */
  projectPath: string
  /** Filesystem watcher options. */
  watch: NapiWatchOptions
  /** The contents of config.js, serialized to JSON. */
  config: string
  /** A map of environment variables to use when compiling code. */
  processEnv: Array<NapiEnvVar>
  /**
   * A map of environment variables which should get injected at compile
   * time.
   */
  defineEnv: NapiDefineEnv
  /** The mode in which Next.js is running. */
  dev: boolean
  /** The build id. */
  buildId: string
  packPath: string
}
/** [NapiProjectOptions] with all fields optional. */
export interface NapiPartialProjectOptions {
  /**
   * A root path from which all files must be nested under. Trying to access
   * a file outside this root will fail. Think of this as a chroot.
   */
  rootPath?: string
  /** A path inside the root_path which contains the app/pages directories. */
  projectPath?: string
  /** Filesystem watcher options. */
  watch?: NapiWatchOptions
  /** The contents of config.js, serialized to JSON. */
  config?: string
  /** A map of environment variables to use when compiling code. */
  processEnv?: Array<NapiEnvVar>
  /**
   * A map of environment variables which should get injected at compile
   * time.
   */
  defineEnv?: NapiDefineEnv
  /** The mode in which Next.js is running. */
  dev?: boolean
  /** The build id. */
  buildId?: string
  /**
   * When the code is minified, this opts out of the default mangling of
   * local names for variables, functions etc., which can be useful for
   * debugging/profiling purposes.
   */
  noMangling?: boolean
  packPath?: string
}
export interface NapiDefineEnv {
  client: Array<NapiEnvVar>
  edge: Array<NapiEnvVar>
  nodejs: Array<NapiEnvVar>
}
export interface NapiTurboEngineOptions {
  /** Use the new backend with persistent caching enabled. */
  persistentCaching?: boolean
  /** An upper bound of memory that turbopack will attempt to stay under. */
  memoryLimit?: number
  /** Track dependencies between tasks. If false, any change during build will error. */
  dependencyTracking?: boolean
}
export declare function projectNew(options: NapiProjectOptions, turboEngineOptions: NapiTurboEngineOptions): Promise<{ __napiType: "Project" }>
export declare function projectUpdate(project: { __napiType: "Project" }, options: NapiPartialProjectOptions): Promise<void>
/**
 * Runs exit handlers for the project registered using the [`ExitHandler`] API.
 *
 * This is called by `project_shutdown`, so if you're calling that API, you shouldn't call this
 * one.
 */
export declare function projectOnExit(project: { __napiType: "Project" }): Promise<void>
/**
 * Runs `project_on_exit`, and then waits for turbo_tasks to gracefully shut down.
 *
 * This is used in builds where it's important that we completely persist turbo-tasks to disk, but
 * it's skipped in the development server (`project_on_exit` is used instead with a short timeout),
 * where we prioritize fast exit and user responsiveness over all else.
 */
export declare function projectShutdown(project: { __napiType: "Project" }): Promise<void>
export interface NapiEntrypoints {
  apps?: Array<ExternalObject<ExternalEndpoint>>
  libraries?: Array<ExternalObject<ExternalEndpoint>>
}
export declare function projectWriteAllEntrypointsToDisk(project: { __napiType: "Project" }): Promise<TurbopackResult>
export declare function projectEntrypointsSubscribe(project: { __napiType: "Project" }, func: (...args: any[]) => any): { __napiType: "RootTask" }
export declare function projectHmrEvents(project: { __napiType: "Project" }, identifier: RcStr, func: (...args: any[]) => any): { __napiType: "RootTask" }
export interface HmrIdentifiers {
  identifiers: Array<string>
}
export declare function projectHmrIdentifiersSubscribe(project: { __napiType: "Project" }, func: (...args: any[]) => any): { __napiType: "RootTask" }
export interface NapiUpdateMessage {
  updateType: string
  value?: NapiUpdateInfo
}
export interface NapiUpdateInfo {
  duration: number
  tasks: number
}
/**
 * Subscribes to lifecycle events of the compilation.
 *
 * Emits an [UpdateMessage::Start] event when any computation starts.
 * Emits an [UpdateMessage::End] event when there was no computation for the
 * specified time (`aggregation_ms`). The [UpdateMessage::End] event contains
 * information about the computations that happened since the
 * [UpdateMessage::Start] event. It contains the duration of the computation
 * (excluding the idle time that was spend waiting for `aggregation_ms`), and
 * the number of tasks that were executed.
 *
 * The signature of the `func` is `(update_message: UpdateMessage) => void`.
 */
export declare function projectUpdateInfoSubscribe(project: { __napiType: "Project" }, aggregationMs: number, func: (...args: any[]) => any): void
export interface StackFrame {
  isServer: boolean
  isInternal?: boolean
  originalFile?: RcStr
  file: RcStr
  /** 1-indexed, unlike source map tokens */
  line?: number
  /** 1-indexed, unlike source map tokens */
  column?: number
  methodName?: RcStr
}
export declare function projectTraceSource(project: { __napiType: "Project" }, frame: StackFrame, currentDirectoryFileUrl: string): Promise<StackFrame | null>
export declare function projectGetSourceForAsset(project: { __napiType: "Project" }, filePath: string): Promise<string | null>
export declare function projectGetSourceMap(project: { __napiType: "Project" }, filePath: RcStr): Promise<string | null>
export declare function projectGetSourceMapSync(project: { __napiType: "Project" }, filePath: RcStr): string | null
export declare function rootTaskDispose(rootTask: { __napiType: "RootTask" }): void
export interface NapiIssue {
  severity: string
  stage: string
  filePath: string
  title: any
  description?: any
  detail?: any
  source?: NapiIssueSource
  documentationLink: string
  importTraces: any
}
export interface NapiIssueSource {
  source: NapiSource
  range?: NapiIssueSourceRange
}
export interface NapiIssueSourceRange {
  start: NapiSourcePos
  end: NapiSourcePos
}
export interface NapiSource {
  ident: string
  content?: string
}
export interface NapiSourcePos {
  line: number
  column: number
}
export interface NapiDiagnostic {
  category: string
  name: string
  payload: Record<string, string>
}
/**
 * Initialize tracing subscriber to emit traces. This configures subscribers
 * for Trace Event Format <https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview>.
 */
export declare function initCustomTraceSubscriber(traceOutFilePath?: string | undefined | null): ExternalObject<RefCell>
/**
 * Teardown currently running tracing subscriber to flush out remaining traces.
 * This should be called when parent node.js process exits, otherwise generated
 * trace may drop traces in the buffer.
 */
export declare function teardownTraceSubscriber(guardExternal: ExternalObject<RefCell>): void
