{"version":3,"file":"predicate.js","sourceRoot":"","sources":["../../../../src/lib/models/types/predicate.ts"],"names":[],"mappings":";;AAAA,yCAAkC;AAUlC,MAAa,aAAc,SAAQ,eAAI;IA2BnC,YAAY,IAAY,EAAE,OAAgB,EAAE,UAAiB;QACzD,KAAK,EAAE,CAAC;QANH,SAAI,GAAG,WAAW,CAAC;QAOxB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;IACjC,CAAC;IAOD,KAAK;QACD,OAAO,IAAI,aAAa,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;IACvE,CAAC;IAQD,MAAM,CAAC,IAAU;;QACb,IAAI,CAAC,CAAC,IAAI,YAAY,aAAa,CAAC,EAAE;YAClC,OAAO,KAAK,CAAC;SAChB;QAED,IAAI,CAAC,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,UAAU,EAAE;YACrC,OAAO,KAAK,CAAC;SAChB;QACD,IAAI,IAAI,CAAC,UAAU,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;YACrC,OAAO,KAAK,CAAC;SAChB;QAED,OAAO,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI;eACvB,IAAI,CAAC,OAAO,KAAK,IAAI,CAAC,OAAO;eAC7B,aAAC,IAAI,CAAC,UAAU,0CAAE,MAAM,CAAC,IAAI,CAAC,UAAW,oCAAK,IAAI,CAAC,CAAC;IAC/D,CAAC;IAKD,QAAQ;QACJ,MAAM,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,SAAS,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAChE,IAAI,IAAI,CAAC,UAAU,EAAE;YACjB,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,CAAC,CAAC;SAC9C;QAED,OAAO,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IACzB,CAAC;CACJ;AA7ED,sCA6EC","sourcesContent":["import { Type } from './abstract';\n\n/**\n * Represents a type predicate.\n *\n * ```ts\n * function isString(anything: any): anything is string {}\n * function assert(condition: boolean): asserts condition {}\n * ```\n */\nexport class PredicateType extends Type {\n    /**\n     * The type that the identifier is tested to be.\n     * May be undefined if the type is of the form `asserts val`.\n     * Will be defined if the type is of the form `asserts val is string` or `val is string`.\n     */\n    targetType?: Type;\n\n    /**\n     * The identifier name which is tested by the predicate.\n     */\n    name: string;\n\n    /**\n     * True if the type is of the form `asserts val is string`, false if\n     * the type is of the form `val is string`\n     */\n    asserts: boolean;\n\n    /**\n     * The type name identifier.\n     */\n    readonly type = 'predicate';\n\n    /**\n     * Create a new PredicateType instance.\n     */\n    constructor(name: string, asserts: boolean, targetType?: Type) {\n        super();\n        this.name = name;\n        this.asserts = asserts;\n        this.targetType = targetType;\n    }\n\n    /**\n     * Clone this type.\n     *\n     * @return A clone of this type.\n     */\n    clone(): Type {\n        return new PredicateType(this.name, this.asserts, this.targetType);\n    }\n\n    /**\n     * Test whether this type equals the given type.\n     *\n     * @param type  The type that should be checked for equality.\n     * @returns TRUE if the given type equals this type, FALSE otherwise.\n     */\n    equals(type: Type): boolean {\n        if (!(type instanceof PredicateType)) {\n            return false;\n        }\n\n        if (!this.targetType && type.targetType) {\n            return false;\n        }\n        if (this.targetType && !type.targetType) {\n            return false;\n        }\n\n        return this.name === type.name\n            && this.asserts === type.asserts\n            && (this.targetType?.equals(type.targetType!) ?? true);\n    }\n\n    /**\n     * Return a string representation of this type.\n     */\n    toString() {\n        const out = this.asserts ? ['asserts', this.name] : [this.name];\n        if (this.targetType) {\n            out.push('is', this.targetType.toString());\n        }\n\n        return out.join(' ');\n    }\n}\n"]}