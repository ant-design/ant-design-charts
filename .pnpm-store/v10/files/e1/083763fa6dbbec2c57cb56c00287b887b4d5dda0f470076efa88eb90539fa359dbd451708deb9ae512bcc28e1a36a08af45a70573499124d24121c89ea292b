{"version":3,"file":"hooks.js","sourceRoot":"","sources":["../../source/types/hooks.ts"],"names":[],"mappings":"","sourcesContent":["import {type stop, type RetryMarker} from '../core/constants.js';\nimport type {KyRequest, KyResponse, HTTPError} from '../index.js';\nimport type {NormalizedOptions} from './options.js';\n\nexport type BeforeRequestState = {\n\t/**\n\tThe number of retries attempted. `0` for the initial request, increments with each retry.\n\n\tThis allows you to distinguish between initial requests and retries, which is useful when you need different behavior for retries (e.g., avoiding overwriting headers set in `beforeRetry`).\n\t*/\n\tretryCount: number;\n};\n\nexport type BeforeRequestHook = (\n\trequest: KyRequest,\n\toptions: NormalizedOptions,\n\tstate: BeforeRequestState\n) => Request | Response | void | Promise<Request | Response | void>;\n\nexport type BeforeRetryState = {\n\trequest: KyRequest;\n\toptions: NormalizedOptions;\n\terror: Error;\n\n\t/**\n\tThe number of retries attempted. Always `>= 1` since this hook is only called during retries, not on the initial request.\n\t*/\n\tretryCount: number;\n};\nexport type BeforeRetryHook = (options: BeforeRetryState) => Request | Response | typeof stop | void | Promise<Request | Response | typeof stop | void>;\n\nexport type AfterResponseState = {\n\t/**\n\tThe number of retries attempted. `0` for the initial request, increments with each retry.\n\n\tThis allows you to distinguish between initial requests and retries, which is useful when you need different behavior for retries (e.g., showing a notification only on the final retry).\n\t*/\n\tretryCount: number;\n};\n\nexport type AfterResponseHook = (\n\trequest: KyRequest,\n\toptions: NormalizedOptions,\n\tresponse: KyResponse,\n\tstate: AfterResponseState\n) => Response | RetryMarker | void | Promise<Response | RetryMarker | void>;\n\nexport type BeforeErrorState = {\n\t/**\n\tThe number of retries attempted. `0` for the initial request, increments with each retry.\n\n\tThis allows you to distinguish between the initial request and retries, which is useful when you need different error handling based on retry attempts (e.g., showing different error messages on the final attempt).\n\t*/\n\tretryCount: number;\n};\n\nexport type BeforeErrorHook = (error: HTTPError, state: BeforeErrorState) => HTTPError | Promise<HTTPError>;\n\nexport type Hooks = {\n\t/**\n\tThis hook enables you to modify the request right before it is sent. Ky will make no further changes to the request after this. The hook function receives the normalized request, options, and a state object. You could, for example, modify `request.headers` here.\n\n\tThe `state.retryCount` is `0` for the initial request and increments with each retry. This allows you to distinguish between initial requests and retries, which is useful when you need different behavior for retries (e.g., avoiding overwriting headers set in `beforeRetry`).\n\n\tA [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) can be returned from this hook to completely avoid making a HTTP request. This can be used to mock a request, check an internal cache, etc. An **important** consideration when returning a `Response` from this hook is that all the following hooks will be skipped, so **ensure you only return a `Response` from the last hook**.\n\n\t@example\n\t```\n\timport ky from 'ky';\n\n\tconst response = await ky('https://example.com', {\n\t\thooks: {\n\t\t\tbeforeRequest: [\n\t\t\t\t(request, options, {retryCount}) => {\n\t\t\t\t\t// Only set default auth header on initial request, not on retries\n\t\t\t\t\t// (retries may have refreshed token set by beforeRetry)\n\t\t\t\t\tif (retryCount === 0) {\n\t\t\t\t\t\trequest.headers.set('Authorization', 'token initial-token');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t});\n\t```\n\n\t@default []\n\t*/\n\tbeforeRequest?: BeforeRequestHook[];\n\n\t/**\n\tThis hook enables you to modify the request right before retry. Ky will make no further changes to the request after this. The hook function receives an object with the normalized request and options, an error instance, and the retry count. You could, for example, modify `request.headers` here.\n\n\tThe hook can return a [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) to replace the outgoing retry request, or return a [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) to skip the retry and use that response instead. **Note:** Returning a request or response skips remaining `beforeRetry` hooks.\n\n\tIf the request received a response, the error will be of type `HTTPError` and the `Response` object will be available at `error.response`. Be aware that some types of errors, such as network errors, inherently mean that a response was not received. In that case, the error will not be an instance of `HTTPError`.\n\n\tYou can prevent Ky from retrying the request by throwing an error. Ky will not handle it in any way and the error will be propagated to the request initiator. The rest of the `beforeRetry` hooks will not be called in this case. Alternatively, you can return the [`ky.stop`](#ky.stop) symbol to do the same thing but without propagating an error (this has some limitations, see `ky.stop` docs for details).\n\n\t**Modifying headers:**\n\n\t@example\n\t```\n\timport ky from 'ky';\n\n\tconst response = await ky('https://example.com', {\n\t\thooks: {\n\t\t\tbeforeRetry: [\n\t\t\t\tasync ({request, options, error, retryCount}) => {\n\t\t\t\t\tconst token = await ky('https://example.com/refresh-token');\n\t\t\t\t\trequest.headers.set('Authorization', `token ${token}`);\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t});\n\t```\n\n\t**Modifying the request URL:**\n\n\t@example\n\t```\n\timport ky from 'ky';\n\n\tconst response = await ky('https://example.com/api', {\n\t\thooks: {\n\t\t\tbeforeRetry: [\n\t\t\t\tasync ({request, error}) => {\n\t\t\t\t\t// Add query parameters based on error response\n\t\t\t\t\tif (error.response) {\n\t\t\t\t\t\tconst body = await error.response.json();\n\t\t\t\t\t\tconst url = new URL(request.url);\n\t\t\t\t\t\turl.searchParams.set('processId', body.processId);\n\t\t\t\t\t\treturn new Request(url, request);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t});\n\t```\n\n\t**Returning a cached response:**\n\n\t@example\n\t```\n\timport ky from 'ky';\n\n\tconst response = await ky('https://example.com/api', {\n\t\thooks: {\n\t\t\tbeforeRetry: [\n\t\t\t\t({error, retryCount}) => {\n\t\t\t\t\t// Use cached response instead of retrying\n\t\t\t\t\tif (retryCount > 1 && cachedResponse) {\n\t\t\t\t\t\treturn cachedResponse;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t});\n\t```\n\n\t@default []\n\t*/\n\tbeforeRetry?: BeforeRetryHook[];\n\n\t/**\n\tThis hook enables you to read and optionally modify the response. The hook function receives normalized request, options, a clone of the response, and a state object. The return value of the hook function will be used by Ky as the response object if it's an instance of [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response).\n\n\tYou can also force a retry by returning `ky.retry()` or `ky.retry(options)`. This is useful when you need to retry based on the response body content, even if the response has a successful status code. The retry will respect the retry limit and be observable in `beforeRetry` hooks.\n\n\t@default []\n\n\t@example\n\t```\n\timport ky from 'ky';\n\n\tconst response = await ky('https://example.com', {\n\t\thooks: {\n\t\t\tafterResponse: [\n\t\t\t\t(_request, _options, response) => {\n\t\t\t\t\t// You could do something with the response, for example, logging.\n\t\t\t\t\tlog(response);\n\n\t\t\t\t\t// Or return a `Response` instance to overwrite the response.\n\t\t\t\t\treturn new Response('A different response', {status: 200});\n\t\t\t\t},\n\n\t\t\t\t// Or retry with a fresh token on a 403 error\n\t\t\t\tasync (request, options, response) => {\n\t\t\t\t\tif (response.status === 403) {\n\t\t\t\t\t\t// Get a fresh token\n\t\t\t\t\t\tconst token = await ky('https://example.com/token').text();\n\n\t\t\t\t\t\t// Retry with the token\n\t\t\t\t\t\toptions.headers.set('Authorization', `token ${token}`);\n\n\t\t\t\t\t\treturn ky(request, options);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Or force retry based on response body content\n\t\t\t\tasync (request, options, response) => {\n\t\t\t\t\tif (response.status === 200) {\n\t\t\t\t\t\tconst data = await response.clone().json();\n\t\t\t\t\t\tif (data.error?.code === 'RATE_LIMIT') {\n\t\t\t\t\t\t\t// Force retry with custom delay from API response\n\t\t\t\t\t\t\treturn ky.retry({\n\t\t\t\t\t\t\t\tdelay: data.error.retryAfter * 1000,\n\t\t\t\t\t\t\t\tcode: 'RATE_LIMIT'\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Or show a notification only on the last retry for 5xx errors\n\t\t\t\t(request, options, response, {retryCount}) => {\n\t\t\t\t\tif (response.status >= 500 && response.status <= 599) {\n\t\t\t\t\t\tif (retryCount === options.retry.limit) {\n\t\t\t\t\t\t\tshowNotification('Request failed after all retries');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t});\n\t```\n\t*/\n\tafterResponse?: AfterResponseHook[];\n\n\t/**\n\tThis hook enables you to modify the `HTTPError` right before it is thrown. The hook function receives a `HTTPError` and a state object as arguments and should return an instance of `HTTPError`.\n\n\t@default []\n\n\t@example\n\t```\n\timport ky from 'ky';\n\n\tawait ky('https://example.com', {\n\t\thooks: {\n\t\t\tbeforeError: [\n\t\t\t\tasync error => {\n\t\t\t\t\tconst {response} = error;\n\t\t\t\t\tif (response) {\n\t\t\t\t\t\tconst body = await response.json();\n\t\t\t\t\t\terror.name = 'GitHubError';\n\t\t\t\t\t\terror.message = `${body.message} (${response.status})`;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn error;\n\t\t\t\t},\n\n\t\t\t\t// Or show different message based on retry count\n\t\t\t\t(error, {retryCount}) => {\n\t\t\t\t\tif (retryCount === error.options.retry.limit) {\n\t\t\t\t\t\terror.message = `${error.message} (failed after ${retryCount} retries)`;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t});\n\t```\n\t*/\n\tbeforeError?: BeforeErrorHook[];\n};\n"]}